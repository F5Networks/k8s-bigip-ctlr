/*-
 * Copyright (c) 2016-2019, F5 Networks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package as3

import (
	"encoding/json"
	"github.com/F5Networks/k8s-bigip-ctlr/pkg/postmanager"
	. "github.com/F5Networks/k8s-bigip-ctlr/pkg/resource"
	log "github.com/F5Networks/k8s-bigip-ctlr/pkg/vlogger"
	"io/ioutil"
	"net/http"

	//routeapi "github.com/openshift/api/route/v1"
)

const (
	defaultAS3ConfigMapLabel = "f5type in (virtual-server), as3 in (true)"
	svcTenantLabel           = "cis.f5.com/as3-tenant"
	svcAppLabel              = "cis.f5.com/as3-app"
	svcPoolLabel             = "cis.f5.com/as3-pool"
	baseAS3Config            = `{
  "$schema": "https://raw.githubusercontent.com/F5Networks/f5-appsvcs-extension/master/schema/latest/as3-schema-3.11.0-3.json",
  "class": "AS3",
  "declaration": {
    "class": "ADC",
    "schemaVersion": "3.11.0",
    "id": "urn:uuid:B97DFADF-9F0D-4F6C-8D66-E9B52E593694",
    "label": "CIS Declaration",
	"remark": "Auto-generated by CIS"
  }
}
`
	as3tenant            = "Tenant"
	as3class             = "class"
	as3SharedApplication = "Shared"
	as3application       = "Application"
	as3shared            = "shared"
	as3template          = "template"
	// Constants for Resource Types
	resourceTypeIngress string = "ingress"
	resourceTypeRoute string = "route"
	//resourceTypeCfgMap string = "cfgMap"
	oprTypeCreate = "create"
	oprTypeUpdate = "update"
	oprTypeDelete = "delete"
	as3SchemaLatestURL = "https://raw.githubusercontent.com/F5Networks/f5-appsvcs-extension/master/schema/latest/as3-schema.json"
	as3SchemaFileName = "as3-schema-3.13.2-1-cis.json"
)

// TODO SNATRA Remove TEMORARY VARIABLE
type endPoints struct{
	members      []Member
}

type AgentRequestConfig struct {
	PoolMembers    map[string]endPoints
	resources      *Resources
	customProfiles *CustomProfileStore
	irulesMap      IRulesMap
	intDgMap       InternalDataGroupMap
	intF5Res       InternalF5ResourcesGroup
}

// AS3Config consists of all the AS3 related configurations
type AS3Config struct {
	as3RsrcType        string
	adc                as3ADC
	configmap          AS3ConfigMap
	overrideConfigmap  AS3ConfigMap
	unifiedDeclaration as3Declaration
}

// ActiveAS3ConfigMap user defined ConfigMap for global availability.
type AS3ConfigMap struct {
	Name       string         // AS3 specific ConfigMap name
	Namespace  string         // AS3 specific ConfigMap namespace
	OprType    string         // Operations like create/update/delete
	State      int            // State of the configMap
	cfg        string         // configuration in combination of "name/namespace" of cfgMap
	tmpData    string         // Holds AS3 template received from cfgMap resource.
	Data       as3Declaration // if AS3 Name is present, populate this with AS3 template data.
}


// AS3AS3Manager holds all the AS3 orchestration specific Data
type AS3Manager struct {
	Agent                     string // TODO SNATRA Remove this
	as3Members                map[Member]struct{}
	as3Validation             bool
	sslInsecure               bool
	enableTLS                 string
	tls13CipherGroupReference string
	ciphers                   string
	// Active User Defined ConfigMap details
	as3ActiveConfig           AS3Config
	// List of Watched Endpoints for user-defined AS3
	watchedAS3Endpoints       map[string]struct{}
	// Watched namespaces
	// WatchedNS                 WatchedNamespaces
	As3SchemaLatest           string
	// Override existing as3 declaration with this configmap
	OverrideAS3Decl           string
	// User defined AS3 declaration
	UserDefinedAS3Decl        string
	// Path of schemas reside locally
	SchemaLocalPath           string
	// Flag to check schema validation using reference or string
	As3SchemaFlag             bool
	// Processed routes for updating Admit Status
	// RoutesProcessed           RouteMap TODO this will move to CIS Core
	// POSTs configuration to BIG-IP using AS3
	PostManager               *postmanager.PostManager
	// To put list of tenants in BIG-IP REST call URL that are in AS3 declaration
	FilterTenants             bool
	DefaultPartition          string
	agentRequestChan          chan AgentRequestConfig
	postmanager.Params
	AgentRequestConfig// This is a temporary
}


// Struct to allow NewManager to receive all or only specific parameters.
type Params struct {
	// Package local for unit testing only
	Agent                     string // TODO SNATRA Remove this
	SchemaLocal               string
	AS3Validation             bool
	SSLInsecure               bool
	EnableTLS                 string
	TLS13CipherGroupReference string
	Ciphers                   string
	//Agent                     string
	OverrideAS3Decl           string
	UserDefinedAS3Decl        string
	SchemaLocalPath           string
	FilterTenants             bool
	BIGIPUsername             string
	BIGIPPassword             string
	BIGIPURL                  string
	TrustedCerts              string
	AS3PostDelay              int
	//Log the AS3 response body in Controller logs
	LogResponse               bool
	//RouteClientV1 routeclient.RouteV1Interface
}



// Create and return a new app manager that meets the Manager interface
func NewAS3Manager(params *Params) *AS3Manager {
	AS3Manager := AS3Manager{
		as3Members:                make(map[Member]struct{}, 0),
		as3Validation:             params.AS3Validation,
		sslInsecure:               params.SSLInsecure,
		enableTLS:                 params.EnableTLS,
		tls13CipherGroupReference: params.TLS13CipherGroupReference,
		ciphers:                   params.Ciphers,
		//OverrideAS3Decl:    params.OverrideAS3Decl,
		//UserDefinedAS3Decl: ,
		SchemaLocalPath: params.SchemaLocal,
		FilterTenants:   params.FilterTenants,
		as3ActiveConfig: AS3Config{
			configmap:         AS3ConfigMap{cfg: params.OverrideAS3Decl},
			overrideConfigmap: AS3ConfigMap{cfg: params.UserDefinedAS3Decl},
		},
		PostManager: postmanager.NewPostManager(postmanager.Params{
				BIGIPUsername: params.BIGIPUsername,
				BIGIPPassword: params.BIGIPPassword,
				BIGIPURL:      params.BIGIPURL,
				TrustedCerts:  params.TrustedCerts,
				SSLInsecure:   params.SSLInsecure,
				AS3PostDelay:  params.AS3PostDelay,
				LogResponse:   params.LogResponse}),
	}
	return &AS3Manager
}




func (as3Mgr *AS3Manager) postAS3Declaration() {

	as3Config := AS3Config{}
	switch as3Mgr.as3ActiveConfig.as3RsrcType {
	case resourceTypeRoute:
		as3Config = as3Mgr.prepareAS3RouteConfig()
	case resourceTypeIngress:
		as3Config = as3Mgr.prepareAS3IngressConfig()
	default:
		// In case of override AS3 and Delete CfgMap
		as3Config = as3Mgr.as3ActiveConfig
	}

	as3Mgr.postAS3Config(as3Config)

	return
}

func (as3Mgr *AS3Manager) postAS3Config(tempAS3Config AS3Config) {
	unifiedDecl := tempAS3Config.getUnifiedDeclaration();
	if unifiedDecl == ""{
		return
	}

	if ok := as3Mgr.validateAS3Template(string(unifiedDecl)); !ok {
		log.Errorf("[AS3] Error in validating declaration  !!!!!! %v", string(unifiedDecl))
		return
	}

	if DeepEqualJSON(as3Mgr.as3ActiveConfig.unifiedDeclaration, unifiedDecl) {
		log.Debug("[AS3] No Change in the Configuration")
		return
	}

	//switch as3Mgr.Agent {
	//case "as3":
	//	as3Mgr.sendFDBEntries()
	//	as3Mgr.sendARPEntries()
	//default:
	//	as3Mgr.outputConfig()
	//}

	as3Mgr.as3ActiveConfig.updateConfig(tempAS3Config)

	var tenants []string = nil
	//var routes []*routeapi.Route
	if as3Mgr.FilterTenants {
		tenants = getTenants(unifiedDecl)
	}
	//if as3Mgr.routeClientV1 != nil {
	//	for _, route := range as3Mgr.RoutesProcessed {
	//		routes = append(routes, route)
	//	}
	//}
	as3Mgr.PostManager.Write(
		string(unifiedDecl),
		tenants,
		nil,
	)
}

func (cfg *AS3Config) updateConfig(newAS3Cfg AS3Config) {
	cfg.configmap.Data = newAS3Cfg.configmap.Data
	cfg.adc = newAS3Cfg.adc
	cfg.overrideConfigmap.Data = newAS3Cfg.overrideConfigmap.Data
	cfg.unifiedDeclaration = newAS3Cfg.unifiedDeclaration
}

func (cfg *AS3Config) getUnifiedDeclaration() as3Declaration {
	if cfg.adc == nil && cfg.configmap.Data == "" {
		return ""
	}

	// Need to process Routes
	var as3Config map[string]interface{}
	if cfg.configmap.Data != "" {
		// Merge activeCfgMap and as3RouteCfg
		_ = json.Unmarshal([]byte(cfg.configmap.Data), &as3Config)
	} else {
		// Merge base AS3 template and as3RouteCfg
		_ = json.Unmarshal([]byte(baseAS3Config), &as3Config)
	}

	if cfg.adc != nil {
		adc, _ := as3Config["declaration"].(map[string]interface{})

		for k, v := range cfg.adc {
			adc[k] = v
		}
	}

	unifiedDecl, err := json.Marshal(as3Config)
	if err != nil {
		log.Debugf("[AS3] Unified declaration: %v\n", err)
	}

	if string(cfg.overrideConfigmap.Data) == "" {
		cfg.unifiedDeclaration = as3Declaration(unifiedDecl)
		return as3Declaration(unifiedDecl)
	}

	overriddenUnifiedDecl := ValidateAndOverrideAS3JsonData(string(cfg.overrideConfigmap.Data),
		string(unifiedDecl))
	if overriddenUnifiedDecl == "" {
		log.Debug("[AS3] Failed to override AS3 Declaration")
		cfg.overrideConfigmap.errorState()
		cfg.unifiedDeclaration = as3Declaration(unifiedDecl)
		return as3Declaration(unifiedDecl)
	}
	cfg.overrideConfigmap.activeState()
	cfg.unifiedDeclaration = as3Declaration(overriddenUnifiedDecl)
	return as3Declaration(overriddenUnifiedDecl)
}

// SNATRA: TODO This has to be modified for AS3 and a new method should be implemented for CCCL
func (as3Mgr *AS3Manager) DeleteAS3Partition(partition string) {
	var as3Config map[string]interface{}
	_ = json.Unmarshal([]byte(baseAS3Config), &as3Config)
	decl := as3Config["declaration"].(map[string]interface{})
	//if as3Mgr.Agent == "cccl" {
	//	decl[DEFAULT_PARTITION+"_AS3"] = map[string]string{"class": "Tenant"}
	decl[partition] = map[string]string{"class": "Tenant"}
	//} else {
	//	return
	//}
	data, _ := json.Marshal(as3Config)

	tempAS3Config := as3Mgr.as3ActiveConfig
	tempAS3Config.configmap.Data = as3Declaration(data)
	as3Mgr.postAS3Config(tempAS3Config)
}

func (c AS3Config) Init (partition string){
	c.adc.initDefault(partition)
	c.configmap.reset()
	c.overrideConfigmap.reset()
}

func (as3Mgr *AS3Manager) FetchAS3Schema() error{

	res, err := http.Get(as3SchemaLatestURL)
	if err != nil {
		log.Debugf("Error while fetching latest as3 schema : %v", err)
		as3Mgr.fallbackToLocalAS3Schema()
		return err
	}
	if res.StatusCode == http.StatusOK {
		body, err := ioutil.ReadAll(res.Body)
		if err != nil {
			log.Debugf("Unable to read the as3 template from json response body : %v", err)
			as3Mgr.fallbackToLocalAS3Schema()
			return err
		}
		defer res.Body.Close()

		jsonMap := make(map[string]interface{})
		err = json.Unmarshal(body, &jsonMap)
		if err != nil {
			log.Debugf("Unable to unmarshal json response body : %v", err)
			as3Mgr.fallbackToLocalAS3Schema()
			return err
		}

		jsonMap["$id"] = as3SchemaLatestURL
		byteJSON, err := json.Marshal(jsonMap)
		if err != nil {
			log.Debugf("Unable to marshal : %v", err)
			as3Mgr.fallbackToLocalAS3Schema()
			return err
		}
		as3Mgr.As3SchemaLatest = string(byteJSON)
		return nil
	}
	as3Mgr.fallbackToLocalAS3Schema()
	return nil
}

func (as3Mgr *AS3Manager) fallbackToLocalAS3Schema() {
	as3Mgr.As3SchemaFlag = true
	log.Debugf("Unable to fetch the latest AS3 schema : validating AS3 schema with %v", as3SchemaFileName)
	as3Mgr.As3SchemaLatest = as3Mgr.SchemaLocalPath + as3SchemaFileName
	return
}
