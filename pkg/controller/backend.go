/*-
 * Copyright (c) 2016-2021, F5 Networks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package controller

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	rsc "github.com/F5Networks/k8s-bigip-ctlr/v2/pkg/resource"
	log "github.com/F5Networks/k8s-bigip-ctlr/v2/pkg/vlogger"
	"github.com/F5Networks/k8s-bigip-ctlr/v2/pkg/writer"
)

const (
	as3SharedApplication = "Shared"
	gtmPartition         = "Common"
)

var baseAS3Config = `{
	"$schema": "https://raw.githubusercontent.com/F5Networks/f5-appsvcs-extension/master/schema/%s/as3-schema-%s.json",
	"class": "AS3",
	"declaration": {
	  "class": "ADC",
	  "schemaVersion": "%s",
	  "id": "urn:uuid:85626792-9ee7-46bb-8fc8-4ba708cfdc1d",
	  "label": "CIS Declaration",
	  "remark": "Auto-generated by CIS",
	  "controls": {
		 "class": "Controls",
		 "userAgent": "CIS Configured AS3"
	  }
	}
  }
`

var DEFAULT_PARTITION string
var DEFAULT_GTM_PARTITION string

func NewAgent(params AgentParams) *Agent {
	DEFAULT_PARTITION = params.Partition
	DEFAULT_GTM_PARTITION = params.Partition + "_gtm"
	postMgr := NewPostManager(params.PostParams)
	configWriter, err := writer.NewConfigWriter()
	if nil != err {
		log.Fatalf("Failed creating ConfigWriter tool: %v", err)
	}
	agent := &Agent{
		PostManager:           postMgr,
		Partition:             params.Partition,
		ConfigWriter:          configWriter,
		EventChan:             make(chan interface{}),
		postChan:              make(chan ResourceConfigRequest, 1),
		retryChan:             make(chan struct{}, 1),
		respChan:              make(chan resourceStatusMeta, 1),
		cachedTenantDeclMap:   make(map[string]as3Tenant),
		incomingTenantDeclMap: make(map[string]as3Tenant),
		retryTenantDeclMap:    make(map[string]*tenantParams),
		tenantPriorityMap:     make(map[string]int),
		userAgent:             params.UserAgent,
		HttpAddress:           params.HttpAddress,
		ccclGTMAgent:          params.CCCLGTMAgent,
		disableARP:            params.DisableARP,
	}
	// agentWorker runs as a separate go routine
	// blocks on postChan to get new/updated configuration to be posted to BIG-IP
	go agent.agentWorker()

	// retryWorker runs as a separate go routine
	// blocks on retryChan ; retries failed declarations and polls for accepted tenant statuses
	go agent.retryWorker()

	// If running in VXLAN mode, extract the partition name from the tunnel
	// to be used in configuring a net instance of CCCL for that partition
	var vxlanPartition string
	if len(params.VXLANName) > 0 {
		cleanPath := strings.TrimLeft(params.VXLANName, "/")
		slashPos := strings.Index(cleanPath, "/")
		if slashPos == -1 {
			// No partition
			vxlanPartition = "Common"
		} else {
			// Partition and name
			vxlanPartition = cleanPath[:slashPos]
		}
	}
	if params.StaticRoutingMode == true {
		vxlanPartition = params.Partition
	}
	gs := globalSection{
		LogLevel:       params.LogLevel,
		VerifyInterval: params.VerifyInterval,
		VXLANPartition: vxlanPartition,
		DisableLTM:     true,
		GTM:            params.CCCLGTMAgent,
		DisableARP:     params.DisableARP,
	}

	bs := bigIPSection{
		BigIPUsername:   params.PostParams.BIGIPUsername,
		BigIPPassword:   params.PostParams.BIGIPPassword,
		BigIPURL:        params.PostParams.BIGIPURL,
		BigIPPartitions: []string{params.Partition},
	}

	var gtm gtmBigIPSection
	if len(params.GTMParams.GTMBigIpUrl) == 0 || len(params.GTMParams.GTMBigIpUsername) == 0 || len(params.GTMParams.GTMBigIpPassword) == 0 {
		// gs.GTM = false
		gtm = gtmBigIPSection{
			GtmBigIPUsername: params.PostParams.BIGIPUsername,
			GtmBigIPPassword: params.PostParams.BIGIPPassword,
			GtmBigIPURL:      params.PostParams.BIGIPURL,
		}
		log.Warning("Creating GTM with default bigip credentials as GTM BIGIP Url or GTM BIGIP Username or GTM BIGIP Password is missing on CIS args.")
	} else {
		gtm = gtmBigIPSection{
			GtmBigIPUsername: params.GTMParams.GTMBigIpUsername,
			GtmBigIPPassword: params.GTMParams.GTMBigIpPassword,
			GtmBigIPURL:      params.GTMParams.GTMBigIpUrl,
		}
	}
	//For IPV6 net config is not required. f5-sdk doesnt support ipv6
	if !(params.EnableIPV6) {
		agent.startPythonDriver(
			gs,
			bs,
			gtm,
			params.PythonBaseDir,
		)
	}
	// Set the AS3 version for the agent
	err = agent.IsBigIPAppServicesAvailable()
	if err != nil {
		log.Errorf("%v", err)
		agent.Stop()
		os.Exit(1)
	}
	return agent
}

func (agent *Agent) Stop() {
	agent.ConfigWriter.Stop()
	if !(agent.EnableIPV6) {
		agent.stopPythonDriver()
	}
}

// Method to verify if App Services are installed or CIS as3 version is
// compatible with BIG-IP, it will return with error if any one of the
// requirements are not met
func (agent *Agent) IsBigIPAppServicesAvailable() error {
	version, build, schemaVersion, err := agent.PostManager.GetBigipAS3Version()
	if err != nil {
		log.Errorf("[AS3] %v ", err)
		return err
	}
	am := as3VersionInfo{
		as3Version:       version,
		as3SchemaVersion: schemaVersion,
		as3Release:       version + "-" + build,
	}
	agent.AS3VersionInfo = am
	versionstr := version[:strings.LastIndex(version, ".")]
	bigIPAS3Version, err := strconv.ParseFloat(versionstr, 64)
	if err != nil {
		log.Errorf("[AS3] Error while converting AS3 version to float")
		return err
	}
	if bigIPAS3Version >= as3SupportedVersion && bigIPAS3Version <= as3Version {
		log.Debugf("[AS3] BIGIP is serving with AS3 version: %v", version)
		return nil
	}

	if bigIPAS3Version > as3Version {
		am.as3Version = defaultAS3Version
		am.as3SchemaVersion = fmt.Sprintf("%.2f.0", as3Version)
		as3Build := defaultAS3Build
		am.as3Release = am.as3Version + "-" + as3Build
		log.Debugf("[AS3] BIGIP is serving with AS3 version: %v", bigIPAS3Version)
		agent.AS3VersionInfo = am
		return nil
	}

	return fmt.Errorf("CIS versions >= 2.0 are compatible with AS3 versions >= %v. "+
		"Upgrade AS3 version in BIGIP from %v to %v or above.", as3SupportedVersion,
		bigIPAS3Version, as3SupportedVersion)
}

func (agent *Agent) PostConfig(rsConfig ResourceConfigRequest) {
	// Always push latest activeConfig to channel
	// Case1: Put latest config into the channel
	// Case2: If channel is blocked because of earlier config, pop out earlier config and push latest config
	// Either Case1 or Case2 executes, which ensures the above
	select {
	case agent.postChan <- rsConfig:
	case <-agent.postChan:
		agent.postChan <- rsConfig

	}
}

// agentWorker blocks on postChan
// whenever it gets unblocked, it creates an as3 declaration for modified tenants and posts the request
func (agent *Agent) agentWorker() {
	for rsConfig := range agent.postChan {
		// For the very first post after starting controller, need not wait to post
		if !agent.firstPost && agent.AS3PostDelay != 0 {
			// Time (in seconds) that CIS waits to post the AS3 declaration to BIG-IP.
			log.Debugf("[AS3] Delaying post to BIG-IP for %v seconds ", agent.AS3PostDelay)
			_ = <-time.After(time.Duration(agent.AS3PostDelay) * time.Second)
		}

		// If there are no retries going on in parallel, acquiring lock will be straight forward.
		// Otherwise, we will wait for retryWorker to complete its current iteration
		agent.declUpdate.Lock()

		// Fetch the latest config from channel
		select {
		case rsConfig = <-agent.postChan:
		case <-time.After(1 * time.Microsecond):
		}

		if !(agent.EnableIPV6) && agent.ccclGTMAgent {
			agent.PostGTMConfig(rsConfig)
		}

		decl := agent.createTenantAS3Declaration(rsConfig)

		if len(agent.incomingTenantDeclMap) == 0 {
			agent.declUpdate.Unlock()
			continue
		}

		var updatedTenants []string
		// initializing the priority tenants
		var priorityTenants []string
		/*
			For every incoming post request, create a new tenantResponseMap.
			tenantResponseMap will be updated with responses during postConfig.
			It holds the updatedTenants in the current iteration's as keys.
			This is needed to update response code in cases (202/404) when httpResponse body does not contain the tenant details.
		*/
		agent.tenantResponseMap = make(map[string]tenantResponse)

		for tenant := range agent.incomingTenantDeclMap {
			// CIS with AS3 doesnt allow write to Common partition.So objects in common partition
			// should not be updated or deleted by CIS. So removing from tenant map
			if tenant != "Common" {
				if _, ok := agent.tenantPriorityMap[tenant]; ok {
					priorityTenants = append(priorityTenants, tenant)
				} else {
					updatedTenants = append(updatedTenants, tenant)
				}
				agent.tenantResponseMap[tenant] = tenantResponse{}
			}
		}

		// Update the priority tenants first
		if len(priorityTenants) > 0 {
			agent.postTenantsDeclaration(decl, rsConfig, priorityTenants)
		}
		// Updating the remaining tenants
		agent.postTenantsDeclaration(decl, rsConfig, updatedTenants)

		agent.declUpdate.Unlock()
	}
}

// Post the tenants declaration
func (agent *Agent) postTenantsDeclaration(decl as3Declaration, rsConfig ResourceConfigRequest, tenants []string) {
	cfg := agentConfig{
		data:      string(decl),
		as3APIURL: agent.getAS3APIURL(tenants),
		id:        rsConfig.reqId,
	}

	agent.publishConfig(cfg)

	// Don't update ARPs if disableARP is set to true
	if !agent.disableARP {
		go agent.updateARPsForPoolMembers(rsConfig)
	}

	agent.updateTenantResponse(true)

	if len(agent.retryTenantDeclMap) > 0 {
		// Activate retry
		select {
		case agent.retryChan <- struct{}{}:
		case <-agent.retryChan:
			agent.retryChan <- struct{}{}
		}
	}

	/*
		If there are any tenants with 201 response code,
		poll for its status continuously and block incoming requests
	*/
	agent.pollTenantStatus()

	// notify resourceStatusUpdate response handler on successful tenant update
	agent.notifyRscStatusHandler(cfg.id, true)
}

func (agent *Agent) notifyRscStatusHandler(id int, overwriteCfg bool) {

	rscUpdateMeta := resourceStatusMeta{
		id,
		make(map[string]struct{}),
	}
	for tenant := range agent.retryTenantDeclMap {
		rscUpdateMeta.failedTenants[tenant] = struct{}{}
	}
	// If triggerred from retry block, process the previous successful request completely
	if !overwriteCfg {
		agent.respChan <- rscUpdateMeta
	} else {
		// Always push latest id to channel
		// Case1: Put latest id into the channel
		// Case2: If channel is blocked because of earlier id, pop out earlier id and push latest id
		// Either Case1 or Case2 executes, which ensures the above
		select {
		case agent.respChan <- rscUpdateMeta:
		case <-agent.respChan:
			agent.respChan <- rscUpdateMeta
		}
	}
}

func (agent *Agent) updateRetryMap(tenant string, resp tenantResponse, tenDecl interface{}) {
	if resp.agentResponseCode == http.StatusOK {
		// delete the tenant entry from retry if any
		delete(agent.retryTenantDeclMap, tenant)
		// if received the 200 response remove the entry from tenantPriorityMap
		if _, ok := agent.tenantPriorityMap[tenant]; ok {
			delete(agent.tenantPriorityMap, tenant)
		}
	} else {
		agent.retryTenantDeclMap[tenant] = &tenantParams{
			tenDecl,
			tenantResponse{resp.agentResponseCode, resp.taskId, false},
		}
	}
}

func (agent *Agent) updateARPsForPoolMembers(rsConfig ResourceConfigRequest) {
	allPoolMembers := rsConfig.ltmConfig.GetAllPoolMembers()

	// Convert allPoolMembers to rsc.Members so that vxlan Manger accepts
	var allPoolMems []rsc.Member

	for _, poolMem := range allPoolMembers {
		allPoolMems = append(
			allPoolMems,
			rsc.Member(poolMem),
		)
	}
	if agent.EventChan != nil {
		select {
		case agent.EventChan <- allPoolMems:
			log.Debugf("Controller wrote endpoints to VxlanMgr")
		case <-time.After(3 * time.Second):
		}
	}
}

func (agent *Agent) updateTenantResponse(agentWorkerUpdate bool) {
	/*
		Non 200 ok tenants will be added to retryTenantDeclMap map
		Locks to update the map will be acquired in the calling method
	*/
	for tenant, resp := range agent.tenantResponseMap {
		if resp.agentResponseCode == 200 {
			if resp.isDeleted {
				// Update the cache tenant map if tenant is deleted.
				delete(agent.cachedTenantDeclMap, tenant)
			} else {
				// update cachedTenantDeclMap with successfully posted declaration
				if agentWorkerUpdate {
					agent.cachedTenantDeclMap[tenant] = agent.incomingTenantDeclMap[tenant]
				} else {
					agent.cachedTenantDeclMap[tenant] = agent.retryTenantDeclMap[tenant].as3Decl.(as3Tenant)
				}
				// if received the 200 response remove the entry from tenantPriorityMap
				if _, ok := agent.tenantPriorityMap[tenant]; ok {
					delete(agent.tenantPriorityMap, tenant)
				}
			}
		}
		if agentWorkerUpdate {
			agent.updateRetryMap(tenant, resp, agent.incomingTenantDeclMap[tenant])
		} else {
			agent.updateRetryMap(tenant, resp, agent.retryTenantDeclMap[tenant].as3Decl)
		}
	}
}

// retryWorker blocks on retryChan
// whenever it gets unblocked, retries failed declarations and polls for accepted tenant statuses
func (agent *Agent) retryWorker() {

	/*
		retryWorker runs as a goroutine. It is idle until an arrives at retryChan.
		retryTenantDeclMal holds all information about tenant adc configuration and response codes.

		Once retryChan is signalled, retryWorker posts tenant declarations and/or polls for accepted tenants' statuses continuously until it succeeds
		Locks are used to block retries if an incoming request arrives at agentWorker.

		For each iteration, retryWorker tries to acquire agent.declUpdate lock.
		During an ongoing agentWorker's activity, retryWorker tries to wait until agent.declUpdate lock is acquired
		Similarly, during an ongoing retry, agentWorker waits for graceful termination of ongoing iteration - i.e., until agent.declUpdate is unlocked

	*/

	for range agent.retryChan {

		for len(agent.retryTenantDeclMap) != 0 {

			agent.declUpdate.Lock()

			// If we had a delay in acquiring lock, re-check if we have any tenants to be retried
			if len(agent.retryTenantDeclMap) == 0 {
				agent.declUpdate.Unlock()
				break
			}

			log.Debugf("[AS3] Posting failed tenants configuration in %v seconds", timeoutMedium)

			//If there are any 201 tenants, poll for its status
			agent.pollTenantStatus()

			//If there are any failed tenants, retry posting them
			agent.retryFailedTenant()

			agent.notifyRscStatusHandler(0, false)

			agent.declUpdate.Unlock()
		}
	}
}

func (agent *Agent) retryFailedTenant() {
	var retryTenants []string

	// this map is to collect all non-201 tenant configs
	retryDecl := make(map[string]as3Tenant)

	agent.tenantResponseMap = make(map[string]tenantResponse)

	for tenant, cfg := range agent.retryTenantDeclMap {
		// So, when we call updateTenantResponse, we have to retain failed agentResponseCodes and taskId's correctly
		agent.tenantResponseMap[tenant] = tenantResponse{agentResponseCode: cfg.agentResponseCode, taskId: cfg.taskId}
		if cfg.taskId == "" {
			retryTenants = append(retryTenants, tenant)
			retryDecl[tenant] = cfg.as3Decl.(as3Tenant)
		}
	}

	if len(retryTenants) > 0 {
		// Until all accepted tenants are not processed, we do not want to re-post failed tenants since we will anyways get a 503
		cfg := agentConfig{
			data:      string(agent.createAS3Declaration(retryDecl)),
			as3APIURL: agent.getAS3APIURL(retryTenants),
			id:        0,
		}
		// Ignoring timeouts for custom errors
		<-time.After(timeoutMedium)

		agent.postConfig(&cfg)

		agent.updateTenantResponse(false)
	}

}

func (agent *Agent) pollTenantStatus() {

	var acceptedTenants []string
	// Create a set to hold unique polling ids
	acceptedTenantIds := map[string]struct{}{}

	agent.tenantResponseMap = make(map[string]tenantResponse)

	for tenant, cfg := range agent.retryTenantDeclMap {
		// So, when we call updateTenantResponse, we have to retain failed agentResponseCodes and taskId's correctly
		agent.tenantResponseMap[tenant] = tenantResponse{agentResponseCode: cfg.agentResponseCode, taskId: cfg.taskId}
		if cfg.taskId != "" {
			if _, found := acceptedTenantIds[cfg.taskId]; !found {
				acceptedTenantIds[cfg.taskId] = struct{}{}
				acceptedTenants = append(acceptedTenants, tenant)
			}
		}
	}

	for len(acceptedTenantIds) > 0 {
		// Keep retrying until accepted tenant statuses are updated
		// This prevents agent from unlocking and thus any incoming post requests (config changes) also need to hold on
		for taskId := range acceptedTenantIds {
			<-time.After(timeoutMedium)
			agent.getTenantConfigStatus(taskId)
		}
		for _, tenant := range acceptedTenants {
			acceptedTenantIds = map[string]struct{}{}
			// Even if there is any pending tenant which is not updated, keep retrying for that ID
			if agent.tenantResponseMap[tenant].taskId != "" {
				acceptedTenantIds[agent.tenantResponseMap[tenant].taskId] = struct{}{}
			}
		}
	}

	if len(acceptedTenants) > 0 {
		agent.updateTenantResponse(false)
	}
}

func (agent *Agent) PostGTMConfig(config ResourceConfigRequest) {

	dnsConfig := make(map[string]interface{})
	wideIPs := WideIPs{}

	for _, gtmPartitionConfig := range config.gtmConfig {
		for _, v := range gtmPartitionConfig.WideIPs {
			wideIPs.WideIPs = append(wideIPs.WideIPs, v)
		}
	}

	dnsConfig["Common"] = wideIPs
	doneCh, errCh, err := agent.ConfigWriter.SendSection("gtm", dnsConfig)

	if nil != err {
		log.Warningf("Failed to write gtm config section: %v", err)
	} else {
		select {
		case <-doneCh:
			log.Debugf("Wrote gtm config section: %v", config.gtmConfig)
		case e := <-errCh:
			log.Warningf("Failed to write gtm config section: %v", e)
		case <-time.After(time.Second):
			log.Warningf("Did not receive write response in 1s")
		}
	}
}

// Creates AS3 adc only for tenants with updated configuration
func (agent *Agent) createTenantAS3Declaration(config ResourceConfigRequest) as3Declaration {
	// Re-initialise incomingTenantDeclMap map and tenantPriorityMap for each new config request
	agent.incomingTenantDeclMap = make(map[string]as3Tenant)
	agent.tenantPriorityMap = make(map[string]int)
	for tenant, cfg := range agent.createAS3LTMAndGTMConfigADC(config) {
		if !reflect.DeepEqual(cfg, agent.cachedTenantDeclMap[tenant]) {
			agent.incomingTenantDeclMap[tenant] = cfg.(as3Tenant)
		} else {
			// cachedTenantDeclMap always holds the current configuration on BigIP(lets say A)
			// When an invalid configuration(B) is reverted (to initial A) (i.e., config state A -> B -> A),
			// delete entry from retryTenantDeclMap if any
			delete(agent.retryTenantDeclMap, tenant)

			log.Debugf("[AS3] No change in %v tenant configuration", tenant)
		}
	}

	// gtmAS3
	//gtmPartitionConfig := agent.createAS3GTMConfigADC(config)
	//if gtmPartitionConfig != nil {
	//	if !reflect.DeepEqual(gtmPartitionConfig, agent.cachedTenantDeclMap[gtmPartition]) {
	//		agent.incomingTenantDeclMap[gtmPartition] = gtmPartitionConfig
	//	} else {
	//		delete(agent.retryTenantDeclMap, gtmPartition)
	//	}
	//}

	return agent.createAS3Declaration(agent.incomingTenantDeclMap)
}

func (agent *Agent) createAS3Declaration(tenantDeclMap map[string]as3Tenant) as3Declaration {
	var as3Config map[string]interface{}

	baseAS3ConfigTemplate := fmt.Sprintf(baseAS3Config, agent.AS3VersionInfo.as3Version, agent.AS3VersionInfo.as3Release, agent.AS3VersionInfo.as3SchemaVersion)
	_ = json.Unmarshal([]byte(baseAS3ConfigTemplate), &as3Config)

	adc := as3Config["declaration"].(map[string]interface{})

	controlObj := make(map[string]interface{})
	controlObj["class"] = "Controls"
	controlObj["userAgent"] = agent.userAgent
	adc["controls"] = controlObj

	for tenant, decl := range tenantDeclMap {
		adc[tenant] = decl
	}
	decl, err := json.Marshal(as3Config)
	if err != nil {
		log.Debugf("[AS3] Unified declaration: %v\n", err)
	}

	return as3Declaration(decl)
}

func (agent *Agent) createAS3LTMAndGTMConfigADC(config ResourceConfigRequest) as3ADC {
	adc := agent.createAS3LTMConfigADC(config)
	if !agent.ccclGTMAgent {
		adc = agent.createAS3GTMConfigADC(config, adc)
	}

	return adc
}

func (agent *Agent) createAS3GTMConfigADC(config ResourceConfigRequest, adc as3ADC) as3ADC {
	if len(config.gtmConfig) == 0 {
		sharedApp := as3Application{}
		sharedApp["class"] = "Application"
		sharedApp["template"] = "shared"

		tenantDecl := as3Tenant{
			"class":              "Tenant",
			as3SharedApplication: sharedApp,
		}
		adc[DEFAULT_GTM_PARTITION] = tenantDecl

		return adc
	}

	for pn, gtmPartitionConfig := range config.gtmConfig {
		var tenantDecl as3Tenant
		var sharedApp as3Application

		if obj, ok := adc[pn]; ok {
			tenantDecl = obj.(as3Tenant)
			sharedApp = tenantDecl[as3SharedApplication].(as3Application)
		} else {
			sharedApp = as3Application{}
			sharedApp["class"] = "Application"
			sharedApp["template"] = "shared"

			tenantDecl = as3Tenant{
				"class":              "Tenant",
				as3SharedApplication: sharedApp,
			}
		}

		for domainName, wideIP := range gtmPartitionConfig.WideIPs {

			gslbDomain := as3GLSBDomain{
				Class:      "GSLB_Domain",
				DomainName: wideIP.DomainName,
				RecordType: wideIP.RecordType,
				LBMode:     wideIP.LBMethod,
				Pools:      make([]as3GSLBDomainPool, 0, len(wideIP.Pools)),
			}
			for _, pool := range wideIP.Pools {
				gslbPool := as3GSLBPool{
					Class:      "GSLB_Pool",
					RecordType: pool.RecordType,
					LBMode:     pool.LBMethod,
					Members:    make([]as3GSLBPoolMemberA, 0, len(pool.Members)),
					Monitors:   make([]as3ResourcePointer, 0, len(pool.Monitors)),
				}

				for _, mem := range pool.Members {
					gslbPool.Members = append(gslbPool.Members, as3GSLBPoolMemberA{
						Enabled: true,
						Server: as3ResourcePointer{
							BigIP: pool.DataServer,
						},
						VirtualServer: mem,
					})
				}

				for _, mon := range pool.Monitors {
					gslbMon := as3GSLBMonitor{
						Class:    "GSLB_Monitor",
						Interval: mon.Interval,
						Type:     mon.Type,
						Send:     mon.Send,
						Receive:  mon.Recv,
						Timeout:  mon.Timeout,
					}

					gslbPool.Monitors = append(gslbPool.Monitors, as3ResourcePointer{
						Use: mon.Name,
					})

					sharedApp[mon.Name] = gslbMon
				}
				gslbDomain.Pools = append(gslbDomain.Pools, as3GSLBDomainPool{Use: pool.Name, Ratio: pool.Ratio})
				sharedApp[pool.Name] = gslbPool
			}

			sharedApp[domainName] = gslbDomain
		}
		adc[pn] = tenantDecl
	}

	return adc
}

func (agent *Agent) createAS3LTMConfigADC(config ResourceConfigRequest) as3ADC {
	adc := as3ADC{}
	for tenant := range agent.cachedTenantDeclMap {
		if _, ok := config.ltmConfig[tenant]; !ok && !agent.isGTMTenant(tenant) {
			// Remove partition
			adc[tenant] = getDeletedTenantDeclaration(agent.Partition, tenant)
		}
	}
	for tenantName, partitionConfig := range config.ltmConfig {
		// TODO partitionConfig priority can be overridden by another request if agent is unable to process the prioritized request in time
		partitionConfig.PriorityMutex.RLock()
		if *(partitionConfig.Priority) > 0 {
			agent.tenantPriorityMap[tenantName] = *(partitionConfig.Priority)
		}
		partitionConfig.PriorityMutex.RUnlock()
		if len(partitionConfig.ResourceMap) == 0 {
			// Remove partition
			adc[tenantName] = getDeletedTenantDeclaration(agent.Partition, tenantName)
			continue
		}
		// Create Shared as3Application object
		sharedApp := as3Application{}
		sharedApp["class"] = "Application"
		sharedApp["template"] = "shared"

		// Process rscfg to create AS3 Resources
		processResourcesForAS3(partitionConfig.ResourceMap, sharedApp, config.shareNodes, tenantName)

		// Process CustomProfiles
		processCustomProfilesForAS3(partitionConfig.ResourceMap, sharedApp)

		// Process Profiles
		processProfilesForAS3(partitionConfig.ResourceMap, sharedApp)

		processIRulesForAS3(partitionConfig.ResourceMap, sharedApp)

		processDataGroupForAS3(partitionConfig.ResourceMap, sharedApp)

		// Create AS3 Tenant
		tenantDecl := as3Tenant{
			"class":              "Tenant",
			"defaultRouteDomain": config.defaultRouteDomain,
			as3SharedApplication: sharedApp,
		}
		adc[tenantName] = tenantDecl
	}
	return adc
}

func getDeletedTenantDeclaration(defaultPartition, tenant string) as3Tenant {
	if defaultPartition == tenant {
		// Flush Partition contents
		sharedApp := as3Application{}
		sharedApp["class"] = "Application"
		sharedApp["template"] = "shared"
		return as3Tenant{
			"class":              "Tenant",
			as3SharedApplication: sharedApp,
		}
	}
	return as3Tenant{
		"class": "Tenant",
	}
}

func processIRulesForAS3(rsMap ResourceMap, sharedApp as3Application) {
	for _, rsCfg := range rsMap {
		// Skip processing IRules for "None" value
		for _, v := range rsCfg.Virtual.IRules {
			if v == "none" {
				continue
			}
		}
		// Create irule declaration
		for _, v := range rsCfg.IRulesMap {
			iRule := &as3IRules{}
			iRule.Class = "iRule"
			iRule.IRule = v.Code
			sharedApp[v.Name] = iRule
		}
	}
}

func processDataGroupForAS3(rsMap ResourceMap, sharedApp as3Application) {
	for _, rsCfg := range rsMap {
		// Skip processing DataGroup for "None" iRule value
		for _, v := range rsCfg.Virtual.IRules {
			if v == "none" {
				continue
			}
		}
		for _, idg := range rsCfg.IntDgMap {
			for _, dg := range idg {
				dataGroupRecord, found := sharedApp[dg.Name]
				if !found {
					dgMap := &as3DataGroup{}
					dgMap.Class = "Data_Group"
					dgMap.KeyDataType = dg.Type
					for _, record := range dg.Records {
						dgMap.Records = append(dgMap.Records, as3Record{Key: record.Name, Value: record.Data})
					}
					// sort above create dgMap records.
					sort.Slice(dgMap.Records, func(i, j int) bool { return (dgMap.Records[i].Key < dgMap.Records[j].Key) })
					sharedApp[dg.Name] = dgMap
				} else {
					for _, record := range dg.Records {
						sharedApp[dg.Name].(*as3DataGroup).Records = append(dataGroupRecord.(*as3DataGroup).Records, as3Record{Key: record.Name, Value: record.Data})
					}
					// sort above created
					sort.Slice(sharedApp[dg.Name].(*as3DataGroup).Records,
						func(i, j int) bool {
							return (sharedApp[dg.Name].(*as3DataGroup).Records[i].Key <
								sharedApp[dg.Name].(*as3DataGroup).Records[j].Key)
						})
				}
			}
		}
	}
}

// Process for AS3 Resource
func processResourcesForAS3(rsMap ResourceMap, sharedApp as3Application, shareNodes bool, tenant string) {
	for _, cfg := range rsMap {
		//Create policies
		createPoliciesDecl(cfg, sharedApp)

		//Create health monitor declaration
		createMonitorDecl(cfg, sharedApp)

		//Create pools
		createPoolDecl(cfg, sharedApp, shareNodes, tenant)

		switch cfg.MetaData.ResourceType {
		case VirtualServer:
			//Create AS3 Service for virtual server
			createServiceDecl(cfg, sharedApp, tenant)
		case TransportServer:
			//Create AS3 Service for transport virtual server
			createTransportServiceDecl(cfg, sharedApp)
		}
	}
}

// Create policy declaration
func createPoliciesDecl(cfg *ResourceConfig, sharedApp as3Application) {
	_, port := extractVirtualAddressAndPort(cfg.Virtual.Destination)
	for _, pl := range cfg.Policies {
		//Create EndpointPolicy
		ep := &as3EndpointPolicy{}
		for _, rl := range pl.Rules {

			ep.Class = "Endpoint_Policy"
			s := strings.Split(pl.Strategy, "/")
			ep.Strategy = s[len(s)-1]

			//Create rules
			rulesData := &as3Rule{Name: rl.Name}

			//Create condition object
			createRuleCondition(rl, rulesData, port)

			//Creat action object
			createRuleAction(rl, rulesData)

			ep.Rules = append(ep.Rules, rulesData)
		}
		//Setting Endpoint_Policy Name
		sharedApp[pl.Name] = ep
	}
}

// Create AS3 Pools for CRD
func createPoolDecl(cfg *ResourceConfig, sharedApp as3Application, shareNodes bool, tenant string) {
	for _, v := range cfg.Pools {
		pool := &as3Pool{}
		pool.LoadBalancingMode = v.Balance
		pool.Class = "Pool"
		pool.ReselectTries = v.ReselectTries
		pool.ServiceDownAction = v.ServiceDownAction
		for _, val := range v.Members {
			var member as3PoolMember
			member.AddressDiscovery = "static"
			member.ServicePort = val.Port
			member.ServerAddresses = append(member.ServerAddresses, val.Address)
			if shareNodes {
				member.ShareNodes = shareNodes
			}
			pool.Members = append(pool.Members, member)
		}
		for _, val := range v.MonitorNames {
			var monitor as3ResourcePointer
			//Reference existing health monitor from BIGIP
			if val.Reference == BIGIP {
				monitor.BigIP = val.Name
			} else {
				use := strings.Split(val.Name, "/")
				monitor.Use = fmt.Sprintf("/%s/%s/%s",
					tenant,
					as3SharedApplication,
					use[len(use)-1],
				)
			}
			pool.Monitors = append(pool.Monitors, monitor)
		}
		sharedApp[v.Name] = pool
	}
}

func updateVirtualToHTTPS(v *as3Service) {
	v.Class = "Service_HTTPS"
	redirect80 := false
	v.Redirect80 = &redirect80
}

// Process Irules for CRD
func processIrulesForCRD(cfg *ResourceConfig, svc *as3Service) {
	var IRules []interface{}
	// Skip processing IRules for "None" value
	for _, v := range cfg.Virtual.IRules {
		if v == "none" {
			continue
		}
		splits := strings.Split(v, "/")
		iRuleName := splits[len(splits)-1]

		var iRuleNoPort string
		lastIndex := strings.LastIndex(iRuleName, "_")
		if lastIndex > 0 {
			iRuleNoPort = iRuleName[:lastIndex]
		} else {
			iRuleNoPort = iRuleName
		}
		if strings.HasSuffix(iRuleNoPort, HttpRedirectIRuleName) ||
			strings.HasSuffix(iRuleNoPort, HttpRedirectNoHostIRuleName) ||
			strings.HasSuffix(iRuleName, TLSIRuleName) ||
			strings.HasSuffix(iRuleName, ABPathIRuleName) {

			IRules = append(IRules, iRuleName)
		} else {
			irule := &as3ResourcePointer{
				BigIP: v,
			}
			IRules = append(IRules, irule)
		}
		svc.IRules = IRules
	}
}

// Create AS3 Service for CRD
func createServiceDecl(cfg *ResourceConfig, sharedApp as3Application, tenant string) {
	svc := &as3Service{}
	numPolicies := len(cfg.Virtual.Policies)
	switch {
	case numPolicies == 1:
		policyName := cfg.Virtual.Policies[0].Name
		svc.PolicyEndpoint = fmt.Sprintf("/%s/%s/%s",
			tenant,
			as3SharedApplication,
			policyName)
	case numPolicies > 1:
		var peps []as3ResourcePointer
		for _, pep := range cfg.Virtual.Policies {
			peps = append(
				peps,
				as3ResourcePointer{
					Use: fmt.Sprintf("/%s/%s/%s",
						tenant,
						as3SharedApplication,
						pep.Name,
					),
				},
			)
		}
		svc.PolicyEndpoint = peps
	case numPolicies == 0:
		// No policies since we need to handle the pool name.
		ps := strings.Split(cfg.Virtual.PoolName, "/")
		if cfg.Virtual.PoolName != "" {
			svc.Pool = fmt.Sprintf("/%s/%s/%s",
				tenant,
				as3SharedApplication,
				ps[len(ps)-1])
		}
	}
	if cfg.Virtual.TLSTermination != TLSPassthrough {
		svc.Layer4 = cfg.Virtual.IpProtocol
		svc.Source = "0.0.0.0/0"
		svc.TranslateServerAddress = true
		svc.TranslateServerPort = true
		svc.Class = "Service_HTTP"
	} else {
		if len(cfg.Virtual.PersistenceProfile) == 0 {
			cfg.Virtual.PersistenceProfile = "tls-session-id"
		}
		svc.Class = "Service_TCP"
	}

	svc.addPersistenceMethod(cfg.Virtual.PersistenceProfile)

	if len(cfg.Virtual.ProfileDOS) > 0 {
		svc.ProfileDOS = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileDOS,
		}
	}
	if len(cfg.Virtual.ProfileBotDefense) > 0 {
		svc.ProfileBotDefense = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileBotDefense,
		}
	}

	if cfg.MetaData.Protocol == "https" {
		if len(cfg.Virtual.HTTP2.Client) > 0 || len(cfg.Virtual.HTTP2.Server) > 0 {
			if cfg.Virtual.HTTP2.Client == "" {
				log.Errorf("[AS3] resetting ProfileHTTP2 as client profile doesnt co-exist with HTTP2 Server Profile, Please include client HTTP2 Profile ")
			}
			if cfg.Virtual.HTTP2.Server == "" {
				svc.ProfileHTTP2 = &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Client),
				}
			}
			if cfg.Virtual.HTTP2.Client == "" && cfg.Virtual.HTTP2.Server != "" {
				svc.ProfileHTTP2 = as3ProfileHTTP2{
					Egress: &as3ResourcePointer{
						BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Server),
					},
				}
			}
			if cfg.Virtual.HTTP2.Client != "" && cfg.Virtual.HTTP2.Server != "" {
				svc.ProfileHTTP2 = as3ProfileHTTP2{
					Ingress: &as3ResourcePointer{
						BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Client),
					},
					Egress: &as3ResourcePointer{
						BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Server),
					},
				}
			}
		}
	}

	if len(cfg.Virtual.TCP.Client) > 0 || len(cfg.Virtual.TCP.Server) > 0 {
		if cfg.Virtual.TCP.Client == "" {
			log.Errorf("[AS3] resetting ProfileTCP as client profile doesnt co-exist with TCP Server Profile, Please include client TCP Profile ")
		}
		if cfg.Virtual.TCP.Server == "" {
			svc.ProfileTCP = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
			}
		}
		if cfg.Virtual.TCP.Client != "" && cfg.Virtual.TCP.Server != "" {
			svc.ProfileTCP = as3ProfileTCP{
				Ingress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
				},
				Egress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Server),
				},
			}
		}
	}

	if len(cfg.Virtual.ProfileMultiplex) > 0 {
		svc.ProfileMultiplex = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileMultiplex,
		}
	}
	// updating the virtual server to https if a passthrough datagroup is found
	name := getRSCfgResName(cfg.Virtual.Name, PassthroughHostsDgName)
	mapKey := NameRef{
		Name:      name,
		Partition: cfg.Virtual.Partition,
	}
	if _, ok := cfg.IntDgMap[mapKey]; ok {
		svc.ServerTLS = &as3ResourcePointer{
			BigIP: "/Common/clientssl",
		}
		updateVirtualToHTTPS(svc)
	}

	// Attaching Profiles from Policy CRD
	for _, profile := range cfg.Virtual.Profiles {
		_, name := getPartitionAndName(profile.Name)
		switch profile.Context {
		case "http":
			if !profile.BigIPProfile {
				svc.ProfileHTTP = name
			} else {
				svc.ProfileHTTP = &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", profile.Name),
				}
			}
		}
	}

	//Attaching WAF policy
	if cfg.Virtual.WAF != "" {
		svc.WAF = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.WAF),
		}
	}

	virtualAddress, port := extractVirtualAddressAndPort(cfg.Virtual.Destination)
	// verify that ip address and port exists.
	if virtualAddress != "" && port != 0 {
		if len(cfg.ServiceAddress) == 0 {
			va := append(svc.VirtualAddresses, virtualAddress)
			if len(cfg.Virtual.AdditionalVirtualAddresses) > 0 {
				for _, val := range cfg.Virtual.AdditionalVirtualAddresses {
					va = append(va, val)
				}
			}
			svc.VirtualAddresses = va
			svc.VirtualPort = port
		} else {
			//Attach Service Address
			serviceAddressName := createServiceAddressDecl(cfg, virtualAddress, sharedApp)
			sa := &as3ResourcePointer{
				Use: serviceAddressName,
			}
			svc.VirtualAddresses = append(svc.VirtualAddresses, sa)
			if len(cfg.Virtual.AdditionalVirtualAddresses) > 0 {
				for _, val := range cfg.Virtual.AdditionalVirtualAddresses {
					//Attach Service Address
					serviceAddressName := createServiceAddressDecl(cfg, val, sharedApp)
					//handle additional service addresses
					asa := &as3ResourcePointer{
						Use: serviceAddressName,
					}
					svc.VirtualAddresses = append(svc.VirtualAddresses, asa)
				}
			}
			svc.VirtualPort = port
		}
	}
	if cfg.Virtual.HttpMrfRoutingEnabled != nil {
		//set HttpMrfRoutingEnabled
		svc.HttpMrfRoutingEnabled = *cfg.Virtual.HttpMrfRoutingEnabled
	}
	svc.AutoLastHop = cfg.Virtual.AutoLastHop

	if cfg.Virtual.AnalyticsProfiles.HTTPAnalyticsProfile != "" {
		svc.HttpAnalyticsProfile = &as3ResourcePointer{
			BigIP: cfg.Virtual.AnalyticsProfiles.HTTPAnalyticsProfile,
		}
	}
	//set websocket profile
	if cfg.Virtual.ProfileWebSocket != "" {
		svc.ProfileWebSocket = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileWebSocket,
		}
	}
	processCommonDecl(cfg, svc)
	sharedApp[cfg.Virtual.Name] = svc
}

// Create AS3 Service Address for Virtual Server Address
func createServiceAddressDecl(cfg *ResourceConfig, virtualAddress string, sharedApp as3Application) string {
	var name string
	for _, sa := range cfg.ServiceAddress {
		serviceAddress := &as3ServiceAddress{}
		serviceAddress.Class = "Service_Address"
		serviceAddress.ArpEnabled = sa.ArpEnabled
		serviceAddress.ICMPEcho = sa.ICMPEcho
		serviceAddress.RouteAdvertisement = sa.RouteAdvertisement
		serviceAddress.SpanningEnabled = sa.SpanningEnabled
		serviceAddress.TrafficGroup = sa.TrafficGroup
		serviceAddress.VirtualAddress = virtualAddress
		name = "crd_service_address_" + AS3NameFormatter(virtualAddress)
		sharedApp[name] = serviceAddress
	}
	return name
}

// Create AS3 Rule Condition for CRD
func createRuleCondition(rl *Rule, rulesData *as3Rule, port int) {
	for _, c := range rl.Conditions {
		condition := &as3Condition{}

		if c.Host {
			condition.Name = "host"
			var values []string
			// For ports other then 80 and 443, attaching port number to host.
			// Ex. example.com:8080
			if port != 80 && port != 443 {
				for i := range c.Values {
					val := c.Values[i] + ":" + strconv.Itoa(port)
					values = append(values, val)
				}
			} else {
				//For ports 80 and 443, host header should match both
				// host and host:port match
				for i := range c.Values {
					val := c.Values[i] + ":" + strconv.Itoa(port)
					values = append(values, val, c.Values[i])
				}
			}
			condition.All = &as3PolicyCompareString{
				Values: values,
			}
			if c.HTTPHost {
				condition.Type = "httpHeader"
			}
			if c.Equals {
				condition.All.Operand = "equals"
			}
			if c.EndsWith {
				condition.All.Operand = "ends-with"
			}
		} else if c.PathSegment {
			condition.PathSegment = &as3PolicyCompareString{
				Values: c.Values,
			}
			if c.Name != "" {
				condition.Name = c.Name
			}
			condition.Index = c.Index
			if c.HTTPURI {
				condition.Type = "httpUri"
			}
			if c.Equals {
				condition.PathSegment.Operand = "equals"
			}
		} else if c.Path {
			condition.Path = &as3PolicyCompareString{
				Values: c.Values,
			}
			if c.Name != "" {
				condition.Name = c.Name
			}
			condition.Index = c.Index
			if c.HTTPURI {
				condition.Type = "httpUri"
			}
			if c.Equals {
				condition.Path.Operand = "equals"
			}
		} else if c.Tcp {
			if c.Address && len(c.Values) > 0 {
				condition.Type = "tcp"
				condition.Address = &as3PolicyAddressString{
					Values: c.Values,
				}
			}
		}
		if c.Request {
			condition.Event = "request"
		}

		rulesData.Conditions = append(rulesData.Conditions, condition)
	}
}

// Create AS3 Rule Action for CRD
func createRuleAction(rl *Rule, rulesData *as3Rule) {
	for _, v := range rl.Actions {
		action := &as3Action{}
		if v.Forward {
			action.Type = "forward"
		}
		if v.Log {
			action.Type = "log"
		}
		if v.Request {
			action.Event = "request"
		}
		if v.Redirect {
			action.Type = "httpRedirect"
		}
		if v.HTTPHost {
			action.Type = "httpHeader"
		}
		if v.HTTPURI {
			action.Type = "httpUri"
		}
		if v.Location != "" {
			action.Location = v.Location
		}
		if v.Log {
			action.Write = &as3LogMessage{
				Message: v.Message,
			}
		}
		// Handle vsHostname rewrite.
		if v.Replace && v.HTTPHost {
			action.Replace = &as3ActionReplaceMap{
				Value: v.Value,
				Name:  "host",
			}
		}
		// handle uri rewrite.
		if v.Replace && v.HTTPURI {
			action.Replace = &as3ActionReplaceMap{
				Value: v.Value,
			}
		}
		p := strings.Split(v.Pool, "/")
		if v.Pool != "" {
			action.Select = &as3ActionForwardSelect{
				Pool: &as3ResourcePointer{
					Use: p[len(p)-1],
				},
			}
		}
		// WAF action
		if v.WAF {
			action.Type = "waf"
		}
		// Add policy reference
		if v.Policy != "" {
			action.Policy = &as3ResourcePointer{
				BigIP: v.Policy,
			}
		}
		if v.Enabled != nil {
			action.Enabled = v.Enabled
		}
		// Add drop action if specified
		if v.Drop {
			action.Type = "drop"
		}

		rulesData.Actions = append(rulesData.Actions, action)
	}
}

// Extract virtual address and port from host URL
func extractVirtualAddressAndPort(str string) (string, int) {

	destination := strings.Split(str, "/")
	// split separator is in accordance with SetVirtualAddress function - ipv4/6 format
	ipPort := strings.Split(destination[len(destination)-1], ":")
	if len(ipPort) != 2 {
		ipPort = strings.Split(destination[len(destination)-1], ".")
	}
	// verify that ip address and port exists else log error.
	if len(ipPort) == 2 {
		port, _ := strconv.Atoi(ipPort[1])
		return ipPort[0], port
	} else {
		log.Error("Invalid Virtual Server Destination IP address/Port.")
		return "", 0
	}

}

func DeepEqualJSON(decl1, decl2 as3Declaration) bool {
	if decl1 == "" && decl2 == "" {
		return true
	}
	var o1, o2 interface{}

	err := json.Unmarshal([]byte(decl1), &o1)
	if err != nil {
		return false
	}

	err = json.Unmarshal([]byte(decl2), &o2)
	if err != nil {
		return false
	}

	return reflect.DeepEqual(o1, o2)
}

func processProfilesForAS3(rsMap ResourceMap, sharedApp as3Application) {
	for _, cfg := range rsMap {
		if svc, ok := sharedApp[cfg.Virtual.Name].(*as3Service); ok {
			processTLSProfilesForAS3(&cfg.Virtual, svc, cfg.Virtual.Name)
		}
	}
}

func processTLSProfilesForAS3(virtual *Virtual, svc *as3Service, profileName string) {
	// lets discard BIGIP profile creation when there exists a custom profile.
	as3ClientSuffix := "_tls_client"
	as3ServerSuffix := "_tls_server"
	var clientProfiles []as3MultiTypeParam
	var serverProfiles []as3MultiTypeParam
	for _, profile := range virtual.Profiles {
		switch profile.Context {
		case CustomProfileClient:
			// Profile is stored in a k8s secret
			if !profile.BigIPProfile {
				// Incoming traffic (clientssl) from a web client will be handled by ServerTLS in AS3
				svc.ServerTLS = fmt.Sprintf("/%v/%v/%v%v", virtual.Partition,
					as3SharedApplication, profileName, as3ServerSuffix)

			} else {
				// Profile is a BIG-IP reference
				// Incoming traffic (clientssl) from a web client will be handled by ServerTLS in AS3
				clientProfiles = append(clientProfiles, &as3ResourcePointer{
					BigIP: fmt.Sprintf("/%v/%v", profile.Partition, profile.Name),
				})
			}
			updateVirtualToHTTPS(svc)
		case CustomProfileServer:
			// Profile is stored in a k8s secret
			if !profile.BigIPProfile {
				// Outgoing traffic (serverssl) to BackEnd Servers from BigIP will be handled by ClientTLS in AS3
				svc.ClientTLS = fmt.Sprintf("/%v/%v/%v%v", virtual.Partition,
					as3SharedApplication, profileName, as3ClientSuffix)
			} else {
				// Profile is a BIG-IP reference
				// Outgoing traffic (serverssl) to BackEnd Servers from BigIP will be handled by ClientTLS in AS3
				serverProfiles = append(serverProfiles, &as3ResourcePointer{
					BigIP: fmt.Sprintf("/%v/%v", profile.Partition, profile.Name),
				})
			}
			updateVirtualToHTTPS(svc)
		}
	}
	if len(clientProfiles) > 0 {
		svc.ServerTLS = clientProfiles
	}
	if len(serverProfiles) > 0 {
		svc.ClientTLS = serverProfiles
	}
}

func processCustomProfilesForAS3(rsMap ResourceMap, sharedApp as3Application) {
	caBundleName := "serverssl_ca_bundle"
	var tlsClient *as3TLSClient
	// TLS Certificates are available in CustomProfiles
	for _, rsCfg := range rsMap {
		// Sort customProfiles so that they are processed in orderly manner
		keys := getSortedCustomProfileKeys(rsCfg.customProfiles)

		for _, key := range keys {
			prof := rsCfg.customProfiles[key]
			// Create TLSServer and Certificate for each profile
			svcName := key.ResourceName
			if svcName == "" {
				continue
			}
			if ok := createUpdateTLSServer(prof, svcName, sharedApp); ok {
				// Create Certificate only if the corresponding TLSServer is created
				createCertificateDecl(prof, sharedApp)
			} else {
				createUpdateCABundle(prof, caBundleName, sharedApp)
				tlsClient = createTLSClient(prof, svcName, caBundleName, sharedApp)

				skey := SecretKey{
					Name: prof.Name + "-ca",
				}
				if _, ok := rsCfg.customProfiles[skey]; ok && tlsClient != nil {
					// If a profile exist in customProfiles with key as created above
					// then it indicates that secure-serverssl needs to be added
					tlsClient.ValidateCertificate = true
				}
			}
		}
	}
}

// createUpdateTLSServer creates a new TLSServer instance or updates if one exists already
func createUpdateTLSServer(prof CustomProfile, svcName string, sharedApp as3Application) bool {
	if len(prof.Certificates) > 0 {
		if sharedApp[svcName] == nil {
			return false
		}
		svc := sharedApp[svcName].(*as3Service)
		tlsServerName := fmt.Sprintf("%s_tls_server", svcName)
		tlsServer, ok := sharedApp[tlsServerName].(*as3TLSServer)
		if !ok {
			tlsServer = &as3TLSServer{
				Class:        "TLS_Server",
				Certificates: []as3TLSServerCertificates{},
			}
			if prof.CipherGroup != "" {
				tlsServer.CipherGroup = &as3ResourcePointer{BigIP: prof.CipherGroup}
				tlsServer.TLS1_3Enabled = true
			} else {
				tlsServer.Ciphers = prof.Ciphers
			}

			sharedApp[tlsServerName] = tlsServer
			svc.ServerTLS = tlsServerName
			updateVirtualToHTTPS(svc)
		}
		for index, certificate := range prof.Certificates {
			certName := fmt.Sprintf("%s_%d", prof.Name, index)
			// A TLSServer profile needs to carry both Certificate and Key
			if len(certificate.Cert) > 0 && len(certificate.Key) > 0 {
				tlsServer.Certificates = append(
					tlsServer.Certificates,
					as3TLSServerCertificates{
						Certificate: certName,
					},
				)
			} else {
				return false
			}
		}
		return true
	}
	return false
}

func createCertificateDecl(prof CustomProfile, sharedApp as3Application) {
	for index, certificate := range prof.Certificates {
		if len(certificate.Cert) > 0 && len(certificate.Key) > 0 {
			cert := &as3Certificate{
				Class:       "Certificate",
				Certificate: certificate.Cert,
				PrivateKey:  certificate.Key,
				ChainCA:     prof.CAFile,
			}
			sharedApp[fmt.Sprintf("%s_%d", prof.Name, index)] = cert
		}
	}
}

func createUpdateCABundle(prof CustomProfile, caBundleName string, sharedApp as3Application) {
	for _, cert := range prof.Certificates {
		// For TLSClient only Cert (DestinationCACertificate) is given and key is empty string
		if len(cert.Cert) > 0 && len(cert.Key) == 0 {
			caBundle, ok := sharedApp[caBundleName].(*as3CABundle)

			if !ok {
				caBundle = &as3CABundle{
					Class:  "CA_Bundle",
					Bundle: "",
				}
				sharedApp[caBundleName] = caBundle
			}
			caBundle.Bundle += "\n" + cert.Cert
		}
	}
}

func createTLSClient(
	prof CustomProfile,
	svcName, caBundleName string,
	sharedApp as3Application,
) *as3TLSClient {

	// For TLSClient only Cert (DestinationCACertificate) is given and key is empty string
	for _, certificate := range prof.Certificates {
		if certificate.Key != "" {
			return nil
		}
	}
	if _, ok := sharedApp[svcName]; len(prof.Certificates) > 0 && ok {
		svc := sharedApp[svcName].(*as3Service)
		tlsClientName := fmt.Sprintf("%s_tls_client", svcName)

		tlsClient := &as3TLSClient{
			Class: "TLS_Client",
			TrustCA: &as3ResourcePointer{
				Use: caBundleName,
			},
		}
		if prof.CipherGroup != "" {
			tlsClient.CipherGroup = &as3ResourcePointer{BigIP: prof.CipherGroup}
			tlsClient.TLS1_3Enabled = true
		} else {
			tlsClient.Ciphers = prof.Ciphers
		}
		sharedApp[tlsClientName] = tlsClient
		svc.ClientTLS = tlsClientName
		updateVirtualToHTTPS(svc)

		return tlsClient
	}
	return nil
}

// Create health monitor declaration
func createMonitorDecl(cfg *ResourceConfig, sharedApp as3Application) {

	for _, v := range cfg.Monitors {
		monitor := &as3Monitor{}
		monitor.Class = "Monitor"
		monitor.Interval = v.Interval
		monitor.MonitorType = v.Type
		monitor.Timeout = v.Timeout
		val := 0
		monitor.TargetPort = v.TargetPort
		targetAddressStr := ""
		monitor.TargetAddress = &targetAddressStr
		//Monitor type
		switch v.Type {
		case "http":
			adaptiveFalse := false
			monitor.Adaptive = &adaptiveFalse
			monitor.Dscp = &val
			monitor.Receive = "none"
			if v.Recv != "" {
				monitor.Receive = v.Recv
			}
			monitor.TimeUnitilUp = &val
			monitor.Send = v.Send
		case "https":
			//Todo: For https monitor type
			adaptiveFalse := false
			monitor.Adaptive = &adaptiveFalse
			if v.Recv != "" {
				monitor.Receive = v.Recv
			}
			monitor.Send = v.Send
		case "tcp", "udp":
			adaptiveFalse := false
			monitor.Adaptive = &adaptiveFalse
			monitor.Receive = v.Recv
			monitor.Send = v.Send
		}
		sharedApp[v.Name] = monitor
	}

}

// Create AS3 transport Service for CRD
func createTransportServiceDecl(cfg *ResourceConfig, sharedApp as3Application) {
	svc := &as3Service{}
	if cfg.Virtual.Mode == "standard" {
		if cfg.Virtual.IpProtocol == "udp" {
			svc.Class = "Service_UDP"
		} else if cfg.Virtual.IpProtocol == "sctp" {
			svc.Class = "Service_SCTP"
		} else {
			svc.Class = "Service_TCP"
		}
	} else if cfg.Virtual.Mode == "performance" {
		svc.Class = "Service_L4"
		if cfg.Virtual.IpProtocol == "udp" {
			svc.Layer4 = "udp"
		} else if cfg.Virtual.IpProtocol == "sctp" {
			svc.Layer4 = "sctp"
		} else {
			svc.Layer4 = "tcp"
		}
	}

	svc.ProfileL4 = "basic"
	if len(cfg.Virtual.ProfileL4) > 0 {
		svc.ProfileL4 = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileL4,
		}
	}

	svc.addPersistenceMethod(cfg.Virtual.PersistenceProfile)

	if len(cfg.Virtual.ProfileDOS) > 0 {
		svc.ProfileDOS = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileDOS,
		}
	}

	if len(cfg.Virtual.ProfileBotDefense) > 0 {
		svc.ProfileBotDefense = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileBotDefense,
		}
	}

	if len(cfg.Virtual.TCP.Client) > 0 || len(cfg.Virtual.TCP.Server) > 0 {
		if cfg.Virtual.TCP.Client == "" {
			log.Errorf("[AS3] resetting ProfileTCP as client profile doesnt co-exist with TCP Server Profile, Please include client TCP Profile ")
		}
		if cfg.Virtual.TCP.Server == "" {
			svc.ProfileTCP = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
			}
		}
		if cfg.Virtual.TCP.Client != "" && cfg.Virtual.TCP.Server != "" {
			svc.ProfileTCP = as3ProfileTCP{
				Ingress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
				},
				Egress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Server),
				},
			}
		}
	}

	// Attaching Profiles from Policy CRD
	for _, profile := range cfg.Virtual.Profiles {
		_, name := getPartitionAndName(profile.Name)
		switch profile.Context {
		case "udp":
			if !profile.BigIPProfile {
				svc.ProfileUDP = name
			} else {
				svc.ProfileUDP = &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", profile.Name),
				}
			}
		}
	}

	if cfg.Virtual.TranslateServerAddress == true {
		svc.TranslateServerAddress = cfg.Virtual.TranslateServerAddress
	}
	if cfg.Virtual.TranslateServerPort == true {
		svc.TranslateServerPort = cfg.Virtual.TranslateServerPort
	}
	if cfg.Virtual.Source != "" {
		svc.Source = cfg.Virtual.Source
	}
	virtualAddress, port := extractVirtualAddressAndPort(cfg.Virtual.Destination)
	// verify that ip address and port exists.
	if virtualAddress != "" && port != 0 {
		if len(cfg.ServiceAddress) == 0 {
			va := append(svc.VirtualAddresses, virtualAddress)
			svc.VirtualAddresses = va
			svc.VirtualPort = port
		} else {
			//Attach Service Address
			serviceAddressName := createServiceAddressDecl(cfg, virtualAddress, sharedApp)
			sa := &as3ResourcePointer{
				Use: serviceAddressName,
			}
			svc.VirtualAddresses = append(svc.VirtualAddresses, sa)
			svc.VirtualPort = port
		}
	}
	svc.Pool = cfg.Virtual.PoolName
	processCommonDecl(cfg, svc)
	sharedApp[cfg.Virtual.Name] = svc
}

// Process common declaration for VS and TS
func processCommonDecl(cfg *ResourceConfig, svc *as3Service) {

	if cfg.Virtual.SNAT == "auto" || cfg.Virtual.SNAT == "none" {
		svc.SNAT = cfg.Virtual.SNAT
	} else {
		svc.SNAT = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.SNAT),
		}
	}

	//Attach AllowVLANs
	if cfg.Virtual.AllowVLANs != nil {
		for _, vlan := range cfg.Virtual.AllowVLANs {
			vlans := as3ResourcePointer{BigIP: vlan}
			svc.AllowVLANs = append(svc.AllowVLANs, vlans)
		}
	}

	//Attach Firewall policy
	if cfg.Virtual.Firewall != "" {
		svc.Firewall = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.Firewall),
		}
	}

	//Attach ipIntelligence policy
	if cfg.Virtual.IpIntelligencePolicy != "" {
		svc.IpIntelligencePolicy = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.IpIntelligencePolicy),
		}
	}

	//Attach logging profile
	if cfg.Virtual.LogProfiles != nil {
		for _, lp := range cfg.Virtual.LogProfiles {
			logProfile := as3ResourcePointer{BigIP: lp}
			svc.LogProfiles = append(svc.LogProfiles, logProfile)
		}
	}

	//Process iRules for crd
	processIrulesForCRD(cfg, svc)
}

// getSortedCustomProfileKeys sorts customProfiles by names and returns secretKeys in that order
func getSortedCustomProfileKeys(customProfiles map[SecretKey]CustomProfile) []SecretKey {
	keys := make([]SecretKey, len(customProfiles))
	i := 0
	for key := range customProfiles {
		keys[i] = key
		i++
	}
	sort.Slice(keys, func(i, j int) bool {
		return customProfiles[keys[i]].Name < customProfiles[keys[j]].Name
	})
	return keys
}

// addPersistenceMethod adds persistence methods in the service declaration
func (svc *as3Service) addPersistenceMethod(persistenceProfile string) {
	if len(persistenceProfile) == 0 {
		return
	}
	switch persistenceProfile {
	case "none":
		svc.PersistenceMethods = &[]as3MultiTypeParam{}
	case "cookie", "destination-address", "hash", "msrdp", "sip-info", "source-address", "tls-session-id", "universal":
		svc.PersistenceMethods = &[]as3MultiTypeParam{as3MultiTypeParam(persistenceProfile)}
	default:
		svc.PersistenceMethods = &[]as3MultiTypeParam{
			as3MultiTypeParam(
				as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", persistenceProfile),
				},
			),
		}
	}
}

func (agent *Agent) isGTMTenant(partition string) bool {
	return partition == DEFAULT_GTM_PARTITION
}
