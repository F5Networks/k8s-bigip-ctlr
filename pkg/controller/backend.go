/*-
 * Copyright (c) 2016-2021, F5 Networks, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package controller

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	rsc "github.com/F5Networks/k8s-bigip-ctlr/v2/pkg/resource"
	log "github.com/F5Networks/k8s-bigip-ctlr/v2/pkg/vlogger"
	"github.com/F5Networks/k8s-bigip-ctlr/v2/pkg/writer"
	"k8s.io/apimachinery/pkg/util/intstr"
)

const (
	as3SharedApplication = "Shared"
	gtmPartition         = "Common"
)

var baseAS3Config = `{
	"$schema": "https://raw.githubusercontent.com/F5Networks/f5-appsvcs-extension/main/schema/%s/as3-schema-%s.json",
	"class": "AS3",
	"declaration": {
	  "class": "ADC",
	  "schemaVersion": "%s",
	  "id": "urn:uuid:85626792-9ee7-46bb-8fc8-4ba708cfdc1d",
	  "label": "CIS Declaration",
	  "remark": "Auto-generated by CIS",
	  "controls": {
		 "class": "Controls",
		 "userAgent": "CIS Configured AS3"
	  }
	}
  }
`

var DEFAULT_PARTITION string
var DEFAULT_GTM_PARTITION string

func NewAgent(params AgentParams) *Agent {
	DEFAULT_PARTITION = params.Partition
	DEFAULT_GTM_PARTITION = params.Partition + "_gtm"
	postMgr := NewPostManager(params, false)
	configWriter, err := writer.NewConfigWriter()
	if nil != err {
		log.Fatalf("Failed creating ConfigWriter tool: %v", err)
	}
	agent := &Agent{
		PostManager:  postMgr,
		Partition:    params.Partition,
		ConfigWriter: configWriter,
		EventChan:    make(chan interface{}),
		respChan:     make(chan resourceStatusMeta, 1),
		userAgent:    params.UserAgent,
		HttpAddress:  params.HttpAddress,
		ccclGTMAgent: params.CCCLGTMAgent,
		disableARP:   params.DisableARP,
	}
	// if agent is running in as3 gtm mode and bipip gtm is different from bigip ltm create the gtm agent
	if isGTMOnSeparateServer(params) {
		agent.GTMPostManager = NewGTMPostManager(params)
		go agent.gtmWorker()
		// retryGTMWorker runs as a separate go routine
		// blocks on retryChan ; retries failed declarations and polls for accepted tenant statuses
		go agent.retryGTMWorker()
	}
	// agentWorker runs as a separate go routine
	// blocks on postChan to get new/updated configuration to be posted to BIG-IP
	go agent.agentWorker()

	// retryWorker runs as a separate go routine
	// blocks on retryChan ; retries failed declarations and polls for accepted tenant statuses
	go agent.retryWorker()

	// If running in VXLAN mode, extract the partition name from the tunnel
	// to be used in configuring a net instance of CCCL for that partition
	var vxlanPartition string
	if len(params.VXLANName) > 0 {
		cleanPath := strings.TrimLeft(params.VXLANName, "/")
		slashPos := strings.Index(cleanPath, "/")
		if slashPos == -1 {
			// No partition
			vxlanPartition = "Common"
		} else {
			// Partition and name
			vxlanPartition = cleanPath[:slashPos]
		}
	}
	if params.StaticRoutingMode == true {
		vxlanPartition = params.Partition
		if params.SharedStaticRoutes == true {
			vxlanPartition = "Common"
		}
	}
	gs := globalSection{
		LogLevel:          params.LogLevel,
		VerifyInterval:    params.VerifyInterval,
		VXLANPartition:    vxlanPartition,
		DisableLTM:        true,
		GTM:               params.CCCLGTMAgent,
		DisableARP:        params.DisableARP,
		StaticRoutingMode: params.StaticRoutingMode,
		MultiClusterMode:  params.MultiClusterMode,
	}

	// If AS3DEBUG is set, set log level to DEBUG
	if gs.LogLevel == "AS3DEBUG" {
		gs.LogLevel = "DEBUG"
	}

	bs := bigIPSection{
		BigIPUsername:   params.PostParams.BIGIPUsername,
		BigIPPassword:   params.PostParams.BIGIPPassword,
		BigIPURL:        params.PostParams.BIGIPURL,
		BigIPPartitions: []string{params.Partition},
	}

	var gtm gtmBigIPSection
	if len(params.GTMParams.BIGIPURL) == 0 || len(params.GTMParams.BIGIPUsername) == 0 || len(params.GTMParams.BIGIPPassword) == 0 {
		// gs.GTM = false
		gtm = gtmBigIPSection{
			GtmBigIPUsername: params.PostParams.BIGIPUsername,
			GtmBigIPPassword: params.PostParams.BIGIPPassword,
			GtmBigIPURL:      params.PostParams.BIGIPURL,
		}
		log.Warning("Creating GTM with default bigip credentials as GTM BIGIP Url or GTM BIGIP Username or GTM BIGIP Password is missing on CIS args.")
	} else {
		gtm = gtmBigIPSection{
			GtmBigIPUsername: params.GTMParams.BIGIPUsername,
			GtmBigIPPassword: params.GTMParams.BIGIPPassword,
			GtmBigIPURL:      params.GTMParams.BIGIPURL,
		}
	}
	//For IPV6 net config is not required. f5-sdk doesnt support ipv6
	if !(params.EnableIPV6) {
		agent.startPythonDriver(
			gs,
			bs,
			gtm,
			params.PythonBaseDir,
		)
	} else {
		// we only enable metrics as pythondriver is not initialized for ipv6
		go agent.enableMetrics()
	}
	// Set the AS3 version for the LTM Postmanager
	err = agent.IsBigIPAppServicesAvailable()
	if err != nil {
		log.Errorf("%v", err)
		agent.Stop()
		os.Exit(1)
	}
	// Set the AS3 version on the GTM Postmanager
	if agent.GTMPostManager != nil {
		err = agent.GTMPostManager.IsBigIPAppServicesAvailable()
		if err != nil {
			log.Errorf("%v", err)
			agent.Stop()
			os.Exit(1)
		}
	}
	return agent
}

func (agent *Agent) Stop() {
	agent.ConfigWriter.Stop()
	if !(agent.EnableIPV6) {
		agent.stopPythonDriver()
	}
}

func (agent *Agent) PostConfig(rsConfig ResourceConfigRequest) {
	// Always push latest activeConfig to channel
	// Case1: Put latest config into the channel
	// Case2: If channel is blocked because of earlier config, pop out earlier config and push latest config
	// Either Case1 or Case2 executes, which ensures the above

	select {
	case agent.postChan <- rsConfig:
	case <-agent.postChan:
		agent.postChan <- rsConfig

	}
}

// removeDeletedTenantsForBigIP will check the tenant exists on bigip or not
// if tenant exists and rsConfig does not have tenant, update the tenant with empty PartitionConfig
func (agent *Agent) removeDeletedTenantsForBigIP(rsConfig *ResourceConfigRequest, cisLabel string) {
	//Fetching the latest BIGIP Configuration and identify if any tenant needs to be deleted
	as3Config, err := agent.PostManager.GetAS3DeclarationFromBigIP()
	if err != nil {
		log.Errorf("[AS3] Could not fetch the latest AS3 declaration from BIG-IP")
	}
	for k, v := range as3Config {
		if decl, ok := v.(map[string]interface{}); ok {
			if label, found := decl["label"]; found && label == cisLabel && k != agent.Partition+"_gtm" {
				if _, ok := rsConfig.ltmConfig[k]; !ok {
					// adding an empty tenant to delete the tenant from BIGIP
					priority := 1
					rsConfig.ltmConfig[k] = &PartitionConfig{Priority: &priority}
				}
			}
		}
	}
}

// agentWorker blocks on postChan
// whenever it gets unblocked, it creates an as3 declaration for modified tenants and posts the request
func (agent *Agent) agentWorker() {
	for rsConfig := range agent.postChan {
		// For the very first post after starting controller, need not wait to post
		if !agent.firstPost && agent.AS3PostDelay != 0 {
			// Time (in seconds) that CIS waits to post the AS3 declaration to BIG-IP.
			log.Debugf("[AS3] Delaying post to BIG-IP for %v seconds ", agent.AS3PostDelay)
			_ = <-time.After(time.Duration(agent.AS3PostDelay) * time.Second)
		}

		// If there are no retries going on in parallel, acquiring lock will be straight forward.
		// Otherwise, we will wait for other workers to complete its current iteration
		agent.declUpdate.Lock()

		// Fetch the latest config from channel
		select {
		case rsConfig = <-agent.postChan:
			log.Infof("%v[AS3] Processing request", getRequestPrefix(rsConfig.reqId))
		case <-time.After(1 * time.Microsecond):
		}

		if !(agent.EnableIPV6) && agent.ccclGTMAgent {
			agent.PostGTMConfig(rsConfig)
		}
		// put GMT config in the post channel if gtm agent is running
		if agent.GTMPostManager != nil {
			agent.GTMPostManager.PostGTMConfig(rsConfig)
		}
		log.Infof("%v[AS3] creating a new AS3 manifest", getRequestPrefix(rsConfig.reqId))
		decl := agent.createTenantAS3Declaration(rsConfig)

		if len(agent.incomingTenantDeclMap) == 0 {
			log.Infof("%v[AS3] No tenants found in request", getRequestPrefix(rsConfig.reqId))
			// notify resourceStatusUpdate response handler for resourcestatus update
			agent.notifyRscStatusHandler(rsConfig.reqId, false)
			agent.declUpdate.Unlock()
			continue
		}

		if agent.HAMode {
			// if endPoint is not empty means, cis is running in secondary mode
			// check if the primary cis is up and running
			if agent.PrimaryClusterHealthProbeParams.EndPointType != "" {
				if agent.PrimaryClusterHealthProbeParams.statusRunning {
					// dont post the declaration
					agent.declUpdate.Unlock()
					continue
				} else {
					if agent.PrimaryClusterHealthProbeParams.statusChanged {
						agent.PrimaryClusterHealthProbeParams.paramLock.Lock()
						agent.PrimaryClusterHealthProbeParams.statusChanged = false
						agent.PrimaryClusterHealthProbeParams.paramLock.Unlock()
					}
				}
			}
		}

		var updatedTenants []string
		// initializing the priority tenants
		var priorityTenants []string
		/*
			For every incoming post request, create a new tenantResponseMap.
			tenantResponseMap will be updated with responses during postConfig.
			It holds the updatedTenants in the current iteration's as keys.
			This is needed to update response code in cases (202/404) when httpResponse body does not contain the tenant details.
		*/
		agent.tenantResponseMap = make(map[string]tenantResponse)

		for tenant := range agent.incomingTenantDeclMap {
			// CIS with AS3 doesnt allow write to Common partition.So objects in common partition
			// should not be updated or deleted by CIS. So removing from tenant map
			if tenant != "Common" {
				if _, ok := agent.tenantPriorityMap[tenant]; ok {
					priorityTenants = append(priorityTenants, tenant)
				} else {
					updatedTenants = append(updatedTenants, tenant)
				}
				agent.tenantResponseMap[tenant] = tenantResponse{}
			}
		}

		// Update the priority tenants first
		if len(priorityTenants) > 0 {
			agent.postTenantsDeclaration(decl, rsConfig, priorityTenants)
		}
		// Updating the remaining tenants
		if len(updatedTenants) > 0 {
			agent.postTenantsDeclaration(decl, rsConfig, updatedTenants)
		}

		agent.declUpdate.Unlock()
	}
}

// Post the tenants declaration
func (agent *Agent) postTenantsDeclaration(decl as3Declaration, rsConfig ResourceConfigRequest, tenants []string) {
	cfg := agentConfig{
		data:      string(decl),
		as3APIURL: agent.getAS3APIURL(tenants),
		id:        rsConfig.reqId,
	}

	agent.publishConfig(cfg)

	// Don't update ARPs if disableARP is set to true
	if !agent.disableARP {
		go agent.updateARPsForPoolMembers(rsConfig)
	}

	agent.updateTenantResponseMap(true)

	if len(agent.retryTenantDeclMap) > 0 {
		// Activate retry
		select {
		case agent.retryChan <- struct{}{}:
		case <-agent.retryChan:
			agent.retryChan <- struct{}{}
		}
	}

	/*
		If there are any tenants with 201 response code,
		poll for its status continuously and block incoming requests
	*/
	agent.pollTenantStatus()

	// notify resourceStatusUpdate response handler on successful tenant update
	agent.notifyRscStatusHandler(cfg.id, true)
}

func (agent *Agent) notifyRscStatusHandler(id int, overwriteCfg bool) {

	rscUpdateMeta := resourceStatusMeta{
		id,
		make(map[string]tenantResponse),
	}
	for tenant := range agent.retryTenantDeclMap {
		rscUpdateMeta.failedTenants[tenant] = agent.retryTenantDeclMap[tenant].tenantResponse
	}
	// If triggerred from retry block, process the previous successful request completely
	if !overwriteCfg {
		agent.respChan <- rscUpdateMeta
	} else {
		// Always push latest id to channel
		// Case1: Put latest id into the channel
		// Case2: If channel is blocked because of earlier id, pop out earlier id and push latest id
		// Either Case1 or Case2 executes, which ensures the above
		select {
		case agent.respChan <- rscUpdateMeta:
		case <-agent.respChan:
			agent.respChan <- rscUpdateMeta
		}
	}
}

func (agent *Agent) updateARPsForPoolMembers(rsConfig ResourceConfigRequest) {
	allPoolMembers := rsConfig.ltmConfig.GetAllPoolMembers()

	// Convert allPoolMembers to rsc.Members so that vxlan Manger accepts
	var allPoolMems []rsc.Member

	for _, poolMem := range allPoolMembers {
		if rsConfig.poolMemberType != Auto ||
			(rsConfig.poolMemberType == Auto && poolMem.MemberType != NodePort) {
			allPoolMems = append(
				allPoolMems,
				rsc.Member(poolMem),
			)
		}
	}
	if agent.EventChan != nil {
		select {
		case agent.EventChan <- allPoolMems:
			log.Debugf("Controller wrote endpoints to VxlanMgr")
		case <-time.After(3 * time.Second):
		}
	}
}

// retryWorker blocks on retryChan
// whenever it gets unblocked, retries failed declarations and polls for accepted tenant statuses
func (agent *Agent) retryWorker() {

	/*
		retryWorker runs as a goroutine. It is idle until an arrives at retryChan.
		retryTenantDeclMal holds all information about tenant adc configuration and response codes.

		Once retryChan is signalled, retryWorker posts tenant declarations and/or polls for accepted tenants' statuses continuously until it succeeds
		Locks are used to block retries if an incoming request arrives at agentWorker.

		For each iteration, retryWorker tries to acquire agent.declUpdate lock.
		During an ongoing agentWorker's activity, retryWorker tries to wait until agent.declUpdate lock is acquired
		Similarly, during an ongoing retry, agentWorker waits for graceful termination of ongoing iteration - i.e., until agent.declUpdate is unlocked

	*/

	for range agent.retryChan {

		for len(agent.retryTenantDeclMap) != 0 {
			// Ignoring timeouts for custom errors
			log.Debugf("[AS3] Posting failed tenants configuration in %v seconds", timeoutMedium)
			<-time.After(timeoutMedium)
			if agent.HAMode {
				// if endPoint is not empty -> cis is running in secondary mode
				// check if the primary cis is up and running
				if agent.PrimaryClusterHealthProbeParams.EndPointType != "" {
					if agent.PrimaryClusterHealthProbeParams.statusRunning {
						agent.retryTenantDeclMap = make(map[string]*tenantParams)
						// dont post the declaration
						continue
					}
				}
			}

			agent.declUpdate.Lock()

			// If we had a delay in acquiring lock, re-check if we have any tenants to be retried
			if len(agent.retryTenantDeclMap) == 0 {
				agent.declUpdate.Unlock()
				break
			}

			//If there are any 201 tenants, poll for its status
			agent.pollTenantStatus()

			//If there are any failed tenants, retry posting them
			agent.retryFailedTenant(agent.userAgent)

			agent.notifyRscStatusHandler(0, false)

			agent.declUpdate.Unlock()
		}
	}
}

func (agent *Agent) PostGTMConfig(config ResourceConfigRequest) {

	dnsConfig := make(map[string]interface{})
	wideIPs := WideIPs{}

	for _, gtmPartitionConfig := range config.gtmConfig {
		for _, v := range gtmPartitionConfig.WideIPs {
			wideIPs.WideIPs = append(wideIPs.WideIPs, v)
		}
	}
	deletedTenants := []string{}
	activeTenants := []string{}
	for tenant, partitionConfig := range config.ltmConfig {
		if len(partitionConfig.ResourceMap) == 0 {
			deletedTenants = append(deletedTenants, tenant)
		} else {
			activeTenants = append(activeTenants, tenant)
		}
	}
	dnsConfig["deletedTenants"] = deletedTenants
	dnsConfig["activeTenants"] = activeTenants
	wideIpConfig := make(map[string]interface{})
	wideIpConfig["Common"] = wideIPs
	dnsConfig["config"] = wideIpConfig
	doneCh, errCh, err := agent.ConfigWriter.SendSection("gtm", dnsConfig)

	if nil != err {
		log.Warningf("Failed to write gtm config section: %v", err)
	} else {
		select {
		case <-doneCh:
			log.Debugf("Wrote gtm config section: %v", config.gtmConfig)
		case e := <-errCh:
			log.Warningf("Failed to write gtm config section: %v", e)
		case <-time.After(time.Second):
			log.Warningf("Did not receive write response in 1s")
		}
	}
}

// Creates AS3 adc only for tenants with updated configuration
func (agent *Agent) createTenantAS3Declaration(config ResourceConfigRequest) as3Declaration {
	// Re-initialise incomingTenantDeclMap map and tenantPriorityMap for each new config request
	agent.incomingTenantDeclMap = make(map[string]as3Tenant)
	agent.tenantPriorityMap = make(map[string]int)
	for tenant, cfg := range agent.createAS3LTMAndGTMConfigADC(config) {
		if !reflect.DeepEqual(cfg, agent.cachedTenantDeclMap[tenant]) ||
			(agent.PrimaryClusterHealthProbeParams.EndPoint != "" && agent.PrimaryClusterHealthProbeParams.statusChanged) {
			agent.incomingTenantDeclMap[tenant] = cfg.(as3Tenant)
		} else {
			// cachedTenantDeclMap always holds the current configuration on BigIP(lets say A)
			// When an invalid configuration(B) is reverted (to initial A) (i.e., config state A -> B -> A),
			// delete entry from retryTenantDeclMap if any
			delete(agent.retryTenantDeclMap, tenant)
			// Log only when it's primary/standalone CIS or when it's secondary CIS and primary CIS is down
			if agent.PrimaryClusterHealthProbeParams.EndPoint == "" || !agent.PrimaryClusterHealthProbeParams.statusRunning {
				log.Debugf("[AS3] No change in %v tenant configuration", tenant)
			}
		}
	}

	// gtmAS3
	//gtmPartitionConfig := agent.createAS3GTMConfigADC(config)
	//if gtmPartitionConfig != nil {
	//	if !reflect.DeepEqual(gtmPartitionConfig, agent.cachedTenantDeclMap[gtmPartition]) {
	//		agent.incomingTenantDeclMap[gtmPartition] = gtmPartitionConfig
	//	} else {
	//		delete(agent.retryTenantDeclMap, gtmPartition)
	//	}
	//}

	return agent.createAS3Declaration(agent.incomingTenantDeclMap, agent.userAgent)
}

func (agent *Agent) createAS3LTMAndGTMConfigADC(config ResourceConfigRequest) as3ADC {
	adc := agent.createAS3LTMConfigADC(config)
	if !agent.ccclGTMAgent && agent.GTMPostManager == nil {
		adc = agent.createAS3GTMConfigADC(config, adc)
	}
	return adc
}

func (agent *Agent) createAS3GTMConfigADC(config ResourceConfigRequest, adc as3ADC) as3ADC {
	if len(config.gtmConfig) == 0 {
		sharedApp := as3Application{}
		sharedApp["class"] = "Application"
		sharedApp["template"] = "shared"
		cisLabel := agent.Partition
		tenantDecl := as3Tenant{
			"class":              "Tenant",
			as3SharedApplication: sharedApp,
			"label":              cisLabel,
		}
		adc[DEFAULT_GTM_PARTITION] = tenantDecl

		return adc
	}

	for pn, gtmPartitionConfig := range config.gtmConfig {
		var tenantDecl as3Tenant
		var sharedApp as3Application

		if obj, ok := adc[pn]; ok {
			tenantDecl = obj.(as3Tenant)
			sharedApp = tenantDecl[as3SharedApplication].(as3Application)
		} else {
			sharedApp = as3Application{}
			sharedApp["class"] = "Application"
			sharedApp["template"] = "shared"

			tenantDecl = as3Tenant{
				"class":              "Tenant",
				as3SharedApplication: sharedApp,
			}
		}

		for domainName, wideIP := range gtmPartitionConfig.WideIPs {

			gslbDomain := as3GLSBDomain{
				Class:              "GSLB_Domain",
				DomainName:         wideIP.DomainName,
				RecordType:         wideIP.RecordType,
				LBMode:             wideIP.LBMethod,
				PersistenceEnabled: wideIP.PersistenceEnabled,
				PersistCidrIPv4:    wideIP.PersistCidrIPv4,
				PersistCidrIPv6:    wideIP.PersistCidrIPv6,
				TTLPersistence:     wideIP.TTLPersistence,
				Pools:              make([]as3GSLBDomainPool, 0, len(wideIP.Pools)),
			}
			if wideIP.ClientSubnetPreferred != nil {
				gslbDomain.ClientSubnetPreferred = wideIP.ClientSubnetPreferred
			}
			for _, pool := range wideIP.Pools {
				gslbPool := as3GSLBPool{
					Class:          "GSLB_Pool",
					RecordType:     pool.RecordType,
					LBMode:         pool.LBMethod,
					LBModeFallback: pool.LBModeFallBack,
					Members:        make([]as3GSLBPoolMemberA, 0, len(pool.Members)),
					Monitors:       make([]as3ResourcePointer, 0, len(pool.Monitors)),
				}

				for _, mem := range pool.Members {
					gslbPool.Members = append(gslbPool.Members, as3GSLBPoolMemberA{
						Enabled: true,
						Server: as3ResourcePointer{
							BigIP: pool.DataServer,
						},
						VirtualServer: mem,
					})
				}

				for _, mon := range pool.Monitors {
					gslbMon := as3GSLBMonitor{
						Class:    "GSLB_Monitor",
						Interval: mon.Interval,
						Type:     mon.Type,
						Send:     mon.Send,
						Receive:  mon.Recv,
						Timeout:  mon.Timeout,
					}

					gslbPool.Monitors = append(gslbPool.Monitors, as3ResourcePointer{
						Use: mon.Name,
					})

					sharedApp[mon.Name] = gslbMon
				}
				gslbDomain.Pools = append(gslbDomain.Pools, as3GSLBDomainPool{Use: pool.Name, Ratio: pool.Ratio})
				sharedApp[pool.Name] = gslbPool
			}

			sharedApp[strings.Replace(domainName, "*", "wildcard", -1)] = gslbDomain
		}
		adc[pn] = tenantDecl
	}

	return adc
}

func (agent *Agent) createAS3LTMConfigADC(config ResourceConfigRequest) as3ADC {
	adc := as3ADC{}
	cisLabel := agent.Partition

	if agent.HAMode {
		// Delete the tenant which is monitored by CIS and current request does not contain it, if it's the first post or
		// if it's secondary CIS and primary CIS is down and statusChanged is true
		if agent.firstPost ||
			(agent.PrimaryClusterHealthProbeParams.EndPoint != "" && !agent.PrimaryClusterHealthProbeParams.statusRunning &&
				agent.PrimaryClusterHealthProbeParams.statusChanged) {
			agent.removeDeletedTenantsForBigIP(&config, cisLabel)
			agent.firstPost = false
		}
	}

	for tenant := range agent.cachedTenantDeclMap {
		if _, ok := config.ltmConfig[tenant]; !ok && !agent.isGTMTenant(tenant) {
			// Remove partition
			adc[tenant] = getDeletedTenantDeclaration(agent.Partition, tenant, cisLabel, &config)
		}
	}
	for tenantName, partitionConfig := range config.ltmConfig {
		// TODO partitionConfig priority can be overridden by another request if agent is unable to process the prioritized request in time
		partitionConfig.PriorityMutex.RLock()
		if *(partitionConfig.Priority) > 0 {
			agent.tenantPriorityMap[tenantName] = *(partitionConfig.Priority)
		}
		partitionConfig.PriorityMutex.RUnlock()
		if len(partitionConfig.ResourceMap) == 0 {
			// Remove partition
			adc[tenantName] = getDeletedTenantDeclaration(agent.Partition, tenantName, cisLabel, &config)
			continue
		}
		// Create Shared as3Application object
		sharedApp := as3Application{}
		sharedApp["class"] = "Application"
		sharedApp["template"] = "shared"

		// Process rscfg to create AS3 Resources
		processResourcesForAS3(partitionConfig.ResourceMap, sharedApp, config.shareNodes, tenantName,
			config.poolMemberType, agent.bigIPAS3Version)

		// Process CustomProfiles
		processCustomProfilesForAS3(partitionConfig.ResourceMap, sharedApp, agent.bigIPAS3Version)

		// Process Profiles
		processProfilesForAS3(partitionConfig.ResourceMap, sharedApp)

		processIRulesForAS3(partitionConfig.ResourceMap, sharedApp)

		processDataGroupForAS3(partitionConfig.ResourceMap, sharedApp)

		// Create AS3 Tenant
		tenantDecl := as3Tenant{
			"class":              "Tenant",
			"defaultRouteDomain": config.defaultRouteDomain,
			as3SharedApplication: sharedApp,
			"label":              cisLabel,
		}
		adc[tenantName] = tenantDecl
	}
	return adc
}

func getDeletedTenantDeclaration(defaultPartition, tenant, cisLabel string, config *ResourceConfigRequest) as3Tenant {
	if defaultPartition == tenant {
		// Flush Partition contents
		sharedApp := as3Application{}
		sharedApp["class"] = "Application"
		sharedApp["template"] = "shared"
		return as3Tenant{
			"class":              "Tenant",
			as3SharedApplication: sharedApp,
			"defaultRouteDomain": config.defaultRouteDomain,
			"label":              cisLabel,
		}
	}
	return as3Tenant{
		"class": "Tenant",
	}
}

func processIRulesForAS3(rsMap ResourceMap, sharedApp as3Application) {
	for _, rsCfg := range rsMap {
		// Skip processing IRules for "None" value
		for _, v := range rsCfg.Virtual.IRules {
			if v == "none" {
				continue
			}
		}
		// Create irule declaration
		for _, v := range rsCfg.IRulesMap {
			iRule := &as3IRules{}
			iRule.Class = "iRule"
			iRule.IRule = v.Code
			sharedApp[v.Name] = iRule
		}
	}
}

func processDataGroupForAS3(rsMap ResourceMap, sharedApp as3Application) {
	for _, rsCfg := range rsMap {
		// Skip processing DataGroup for "None" iRule value
		for _, v := range rsCfg.Virtual.IRules {
			if v == "none" {
				continue
			}
		}
		for _, idg := range rsCfg.IntDgMap {
			for _, dg := range idg {
				dataGroupRecord, found := sharedApp[dg.Name]
				if !found {
					dgMap := &as3DataGroup{}
					dgMap.Class = "Data_Group"
					dgMap.KeyDataType = dg.Type
					for _, record := range dg.Records {
						dgMap.Records = append(dgMap.Records, as3Record{Key: record.Name, Value: record.Data})
					}
					// sort above create dgMap records.
					sort.Slice(dgMap.Records, func(i, j int) bool { return (dgMap.Records[i].Key < dgMap.Records[j].Key) })
					sharedApp[dg.Name] = dgMap
				} else {
					for _, record := range dg.Records {
						sharedApp[dg.Name].(*as3DataGroup).Records = append(dataGroupRecord.(*as3DataGroup).Records, as3Record{Key: record.Name, Value: record.Data})
					}
					// sort above created
					sort.Slice(sharedApp[dg.Name].(*as3DataGroup).Records,
						func(i, j int) bool {
							return (sharedApp[dg.Name].(*as3DataGroup).Records[i].Key <
								sharedApp[dg.Name].(*as3DataGroup).Records[j].Key)
						})
				}
			}
		}
	}
}

// Process for AS3 Resource
func processResourcesForAS3(rsMap ResourceMap, sharedApp as3Application, shareNodes bool, tenant, poolMemberType string, bigipAs3Version float64) {
	for _, cfg := range rsMap {
		//Create policies
		createPoliciesDecl(cfg, sharedApp)

		//Create health monitor declaration
		createMonitorDecl(cfg, sharedApp)

		//Create pools
		createPoolDecl(cfg, sharedApp, shareNodes, tenant, poolMemberType)

		switch cfg.MetaData.ResourceType {
		case VirtualServer:
			//Create AS3 Service for virtual server
			createServiceDecl(cfg, sharedApp, tenant, bigipAs3Version)
		case TransportServer:
			//Create AS3 Service for transport virtual server
			createTransportServiceDecl(cfg, sharedApp, tenant)
		}
	}
}

// Create policy declaration
func createPoliciesDecl(cfg *ResourceConfig, sharedApp as3Application) {
	_, port := extractVirtualAddressAndPort(cfg.Virtual.Destination)
	for _, pl := range cfg.Policies {
		//Create EndpointPolicy
		ep := &as3EndpointPolicy{}
		for _, rl := range pl.Rules {

			ep.Class = "Endpoint_Policy"
			s := strings.Split(pl.Strategy, "/")
			ep.Strategy = s[len(s)-1]

			//Create rules
			rulesData := &as3Rule{Name: rl.Name}

			//Create condition object
			createRuleCondition(rl, rulesData, port)

			//Create action object
			createRuleAction(rl, rulesData)

			ep.Rules = append(ep.Rules, rulesData)
		}
		//Setting Endpoint_Policy Name
		sharedApp[pl.Name] = ep
	}
}

// Create AS3 Pools for CRD
func createPoolDecl(cfg *ResourceConfig, sharedApp as3Application, shareNodes bool, tenant, poolMemberType string) {
	for _, v := range cfg.Pools {
		pool := &as3Pool{}
		pool.LoadBalancingMode = v.Balance
		pool.Class = "Pool"
		pool.ReselectTries = v.ReselectTries
		pool.ServiceDownAction = v.ServiceDownAction
		pool.SlowRampTime = v.SlowRampTime
		poolMemberSet := make(map[PoolMember]struct{})
		for _, val := range v.Members {
			// Skip duplicate pool members
			if _, ok := poolMemberSet[val]; ok {
				continue
			}
			poolMemberSet[val] = struct{}{}
			var member as3PoolMember
			member.AddressDiscovery = "static"
			member.ServicePort = val.Port
			if val.Ratio > 0 {
				member.Ratio = val.Ratio
			}
			member.ServerAddresses = append(member.ServerAddresses, val.Address)
			if shareNodes || (poolMemberType == Auto && val.MemberType == NodePort) {
				member.ShareNodes = true
			}
			if val.AdminState != "" {
				member.AdminState = val.AdminState
			}
			if val.ConnectionLimit != 0 {
				member.ConnectionLimit = val.ConnectionLimit
			}
			pool.Members = append(pool.Members, member)
		}
		for _, val := range v.MonitorNames {
			var monitor as3ResourcePointer
			//Reference existing health monitor from BIGIP
			if val.Reference == BIGIP {
				monitor.BigIP = val.Name
			} else {
				use := strings.Split(val.Name, "/")
				monitor.Use = fmt.Sprintf("/%s/%s/%s",
					tenant,
					as3SharedApplication,
					use[len(use)-1],
				)
			}
			pool.Monitors = append(pool.Monitors, monitor)
		}
		if len(pool.Monitors) > 0 {
			if v.MinimumMonitors.StrVal != "" || v.MinimumMonitors.IntVal != 0 {
				pool.MinimumMonitors = v.MinimumMonitors
			} else {
				pool.MinimumMonitors = intstr.IntOrString{Type: 0, IntVal: 1}
			}
		} else {
			pool.MinimumMonitors = intstr.IntOrString{Type: 1, StrVal: "all"}
		}
		if pl, ok := sharedApp[v.Name]; ok {
			if pl.(*as3Pool) != nil && len(pl.(*as3Pool).Monitors) > 0 {
				for _, mon := range pl.(*as3Pool).Monitors {
					exist := false
					for _, plMon := range pool.Monitors {
						if reflect.DeepEqual(mon, plMon) {
							exist = true
							break
						}
					}
					if !exist {
						pool.Monitors = append(pool.Monitors, mon)
					}
				}
			}
		}
		sharedApp[v.Name] = pool
	}
}

func updateVirtualToHTTPS(v *as3Service) {
	v.Class = "Service_HTTPS"
	redirect80 := false
	v.Redirect80 = &redirect80
}

// Process Irules for CRD
func processIrulesForCRD(cfg *ResourceConfig, svc *as3Service) {
	var IRules []interface{}
	// Skip processing IRules for "None" value
	for _, v := range cfg.Virtual.IRules {
		if v == "none" {
			continue
		}
		splits := strings.Split(v, "/")
		iRuleName := splits[len(splits)-1]

		var iRuleNoPort string
		lastIndex := strings.LastIndex(iRuleName, "_")
		if lastIndex > 0 {
			iRuleNoPort = iRuleName[:lastIndex]
		} else {
			iRuleNoPort = iRuleName
		}
		if strings.HasSuffix(iRuleNoPort, HttpRedirectIRuleName) ||
			strings.HasSuffix(iRuleNoPort, HttpRedirectNoHostIRuleName) ||
			strings.HasSuffix(iRuleName, TLSIRuleName) ||
			strings.HasSuffix(iRuleName, ABPathIRuleName) {

			IRules = append(IRules, iRuleName)
		} else {
			irule := &as3ResourcePointer{
				BigIP: v,
			}
			IRules = append(IRules, irule)
		}
		svc.IRules = IRules
	}
}

// Create AS3 Service for CRD
func createServiceDecl(cfg *ResourceConfig, sharedApp as3Application, tenant string, bigipAs3Version float64) {
	svc := &as3Service{}
	numPolicies := len(cfg.Virtual.Policies)
	switch {
	case numPolicies == 1:
		policyName := cfg.Virtual.Policies[0].Name
		svc.PolicyEndpoint = fmt.Sprintf("/%s/%s/%s",
			tenant,
			as3SharedApplication,
			policyName)
	case numPolicies > 1:
		var peps []as3ResourcePointer
		for _, pep := range cfg.Virtual.Policies {
			peps = append(
				peps,
				as3ResourcePointer{
					Use: fmt.Sprintf("/%s/%s/%s",
						tenant,
						as3SharedApplication,
						pep.Name,
					),
				},
			)
		}
		svc.PolicyEndpoint = peps
	}
	// Attach the default pool if pool name is present for virtual.
	if cfg.Virtual.PoolName != "" {
		var poolPointer as3ResourcePointer
		if cfg.MetaData.defaultPoolType == BIGIP {
			poolPointer.BigIP = cfg.Virtual.PoolName
		} else {
			ps := strings.Split(cfg.Virtual.PoolName, "/")
			poolPointer.Use = fmt.Sprintf("/%s/%s/%s",
				tenant,
				as3SharedApplication,
				ps[len(ps)-1],
			)
		}
		svc.Pool = &poolPointer
	}

	if cfg.Virtual.TLSTermination != TLSPassthrough {
		svc.Layer4 = cfg.Virtual.IpProtocol
		svc.Source = "0.0.0.0/0"
		svc.TranslateServerAddress = true
		svc.TranslateServerPort = true
		svc.Class = "Service_HTTP"
	} else {
		if len(cfg.Virtual.PersistenceProfile) == 0 {
			cfg.Virtual.PersistenceProfile = "tls-session-id"
		}
		svc.Class = "Service_TCP"
	}

	svc.addPersistenceMethod(cfg.Virtual.PersistenceProfile)

	if len(cfg.Virtual.ProfileDOS) > 0 {
		svc.ProfileDOS = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileDOS,
		}
	}
	if len(cfg.Virtual.ProfileBotDefense) > 0 {
		svc.ProfileBotDefense = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileBotDefense,
		}
	}
	if len(cfg.Virtual.HTMLProfile) > 0 {
		svc.ProfileHTML = &as3ResourcePointer{
			BigIP: cfg.Virtual.HTMLProfile,
		}
	}

	if cfg.MetaData.Protocol == "https" {
		if len(cfg.Virtual.HTTP2.Client) > 0 || len(cfg.Virtual.HTTP2.Server) > 0 {
			if cfg.Virtual.HTTP2.Client == "" {
				log.Errorf("[AS3] resetting ProfileHTTP2 as client profile doesnt co-exist with HTTP2 Server Profile, Please include client HTTP2 Profile ")
			}
			if cfg.Virtual.HTTP2.Server == "" {
				svc.ProfileHTTP2 = &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Client),
				}
			}
			if cfg.Virtual.HTTP2.Client == "" && cfg.Virtual.HTTP2.Server != "" {
				svc.ProfileHTTP2 = as3ProfileHTTP2{
					Egress: &as3ResourcePointer{
						BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Server),
					},
				}
			}
			if cfg.Virtual.HTTP2.Client != "" && cfg.Virtual.HTTP2.Server != "" {
				svc.ProfileHTTP2 = as3ProfileHTTP2{
					Ingress: &as3ResourcePointer{
						BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Client),
					},
					Egress: &as3ResourcePointer{
						BigIP: fmt.Sprintf("%v", cfg.Virtual.HTTP2.Server),
					},
				}
			}
		}
	}

	if len(cfg.Virtual.TCP.Client) > 0 || len(cfg.Virtual.TCP.Server) > 0 {
		if cfg.Virtual.TCP.Client == "" {
			log.Errorf("[AS3] resetting ProfileTCP as client profile doesnt co-exist with TCP Server Profile, Please include client TCP Profile ")
		}
		if cfg.Virtual.TCP.Server == "" {
			svc.ProfileTCP = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
			}
		}
		if cfg.Virtual.TCP.Client != "" && cfg.Virtual.TCP.Server != "" {
			svc.ProfileTCP = as3ProfileTCP{
				Ingress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
				},
				Egress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Server),
				},
			}
		}
	}

	if len(cfg.Virtual.ProfileMultiplex) > 0 {
		svc.ProfileMultiplex = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileMultiplex,
		}
	}
	// updating the virtual server to https if a passthrough datagroup is found
	name := getRSCfgResName(cfg.Virtual.Name, PassthroughHostsDgName)
	mapKey := NameRef{
		Name:      name,
		Partition: cfg.Virtual.Partition,
	}
	if _, ok := cfg.IntDgMap[mapKey]; ok {
		if bigipAs3Version < 3.52 {
			svc.ServerTLS = &as3ResourcePointer{
				BigIP: "/Common/clientssl",
			}
		}
		updateVirtualToHTTPS(svc)
	}

	// Attaching Profiles from Policy CRD
	for _, profile := range cfg.Virtual.Profiles {
		_, name := getPartitionAndName(profile.Name)
		switch profile.Context {
		case "http":
			if !profile.BigIPProfile {
				svc.ProfileHTTP = name
			} else {
				svc.ProfileHTTP = &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", profile.Name),
				}
			}
		}
	}

	//Attaching WAF policy
	if cfg.Virtual.WAF != "" {
		svc.WAF = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.WAF),
		}
	}

	virtualAddress, port := extractVirtualAddressAndPort(cfg.Virtual.Destination)
	// verify that ip address and port exists.
	if virtualAddress != "" && port != 0 {
		if len(cfg.ServiceAddress) == 0 {
			va := append(svc.VirtualAddresses, virtualAddress)
			if len(cfg.Virtual.AdditionalVirtualAddresses) > 0 {
				for _, val := range cfg.Virtual.AdditionalVirtualAddresses {
					if cfg.Virtual.BigIPRouteDomain > 0 {
						val = fmt.Sprintf("%s%%%d", val, cfg.Virtual.BigIPRouteDomain)
					}
					va = append(va, val)
				}
			}
			svc.VirtualAddresses = va
			svc.VirtualPort = port
		} else {
			//Attach Service Address
			serviceAddressName := createServiceAddressDecl(cfg, virtualAddress, sharedApp)
			sa := &as3ResourcePointer{
				Use: serviceAddressName,
			}
			svc.VirtualAddresses = append(svc.VirtualAddresses, sa)
			if len(cfg.Virtual.AdditionalVirtualAddresses) > 0 {
				for _, val := range cfg.Virtual.AdditionalVirtualAddresses {
					if cfg.Virtual.BigIPRouteDomain > 0 {
						val = fmt.Sprintf("%s%%%d", val, cfg.Virtual.BigIPRouteDomain)
					}
					//Attach Service Address
					serviceAddressName := createServiceAddressDecl(cfg, val, sharedApp)
					//handle additional service addresses
					asa := &as3ResourcePointer{
						Use: serviceAddressName,
					}
					svc.VirtualAddresses = append(svc.VirtualAddresses, asa)
				}
			}
			svc.VirtualPort = port
		}
	}
	if cfg.Virtual.HttpMrfRoutingEnabled != nil {
		//set HttpMrfRoutingEnabled
		svc.HttpMrfRoutingEnabled = *cfg.Virtual.HttpMrfRoutingEnabled
	}
	svc.AutoLastHop = cfg.Virtual.AutoLastHop

	if cfg.Virtual.AnalyticsProfiles.HTTPAnalyticsProfile != "" {
		svc.HttpAnalyticsProfile = &as3ResourcePointer{
			BigIP: cfg.Virtual.AnalyticsProfiles.HTTPAnalyticsProfile,
		}
	}
	//set websocket profile
	if cfg.Virtual.ProfileWebSocket != "" {
		svc.ProfileWebSocket = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileWebSocket,
		}
	}
	processCommonDecl(cfg, svc)
	sharedApp[cfg.Virtual.Name] = svc
}

// Create AS3 Service Address for Virtual Server Address
func createServiceAddressDecl(cfg *ResourceConfig, virtualAddress string, sharedApp as3Application) string {
	var name string
	for _, sa := range cfg.ServiceAddress {
		serviceAddress := &as3ServiceAddress{}
		serviceAddress.Class = "Service_Address"
		serviceAddress.ArpEnabled = sa.ArpEnabled
		serviceAddress.ICMPEcho = sa.ICMPEcho
		serviceAddress.RouteAdvertisement = sa.RouteAdvertisement
		serviceAddress.SpanningEnabled = sa.SpanningEnabled
		serviceAddress.TrafficGroup = sa.TrafficGroup
		serviceAddress.VirtualAddress = virtualAddress
		name = "crd_service_address_" + AS3NameFormatter(virtualAddress)
		sharedApp[name] = serviceAddress
	}
	return name
}

// Create AS3 Rule Condition for CRD
func createRuleCondition(rl *Rule, rulesData *as3Rule, port int) {
	for _, c := range rl.Conditions {
		condition := &as3Condition{}

		if c.Host {
			condition.Name = "host"
			var values []string
			// For ports other then 80 and 443, attaching port number to host.
			// Ex. example.com:8080
			if port != 80 && port != 443 {
				for i := range c.Values {
					val := c.Values[i] + ":" + strconv.Itoa(port)
					values = append(values, val)
				}
			} else {
				//For ports 80 and 443, host header should match both
				// host and host:port match
				for i := range c.Values {
					val := c.Values[i] + ":" + strconv.Itoa(port)
					values = append(values, val, c.Values[i])
				}
			}
			condition.All = &as3PolicyCompareString{
				Values: values,
			}
			if c.HTTPHost {
				condition.Type = "httpHeader"
			}
			if c.Equals {
				condition.All.Operand = "equals"
			}
			if c.EndsWith {
				condition.All.Operand = "ends-with"
			}
		} else if c.PathSegment {
			condition.PathSegment = &as3PolicyCompareString{
				Values: c.Values,
			}
			if c.Name != "" {
				condition.Name = c.Name
			}
			condition.Index = c.Index
			if c.HTTPURI {
				condition.Type = "httpUri"
			}
			if c.Equals {
				condition.PathSegment.Operand = "equals"
			}
		} else if c.Path {
			condition.Path = &as3PolicyCompareString{
				Values: c.Values,
			}
			if c.Name != "" {
				condition.Name = c.Name
			}
			condition.Index = c.Index
			if c.HTTPURI {
				condition.Type = "httpUri"
			}
			if c.Equals {
				condition.Path.Operand = "equals"
			}
		} else if c.Tcp {
			if c.Address && len(c.Values) > 0 {
				condition.Type = "tcp"
				condition.Address = &as3PolicyAddressString{
					Values: c.Values,
				}
			}
		}
		if c.Request {
			condition.Event = "request"
		}

		rulesData.Conditions = append(rulesData.Conditions, condition)
	}
}

// Create AS3 Rule Action for CRD
func createRuleAction(rl *Rule, rulesData *as3Rule) {
	for _, v := range rl.Actions {
		action := &as3Action{}
		if v.Forward {
			action.Type = "forward"
		}
		if v.Log {
			action.Type = "log"
		}
		if v.Request {
			action.Event = "request"
		}
		if v.Redirect {
			action.Type = "httpRedirect"
		}
		if v.HTTPHost {
			action.Type = "httpHeader"
		}
		if v.HTTPURI {
			action.Type = "httpUri"
		}
		if v.Location != "" {
			action.Location = v.Location
		}
		if v.Log {
			action.Write = &as3LogMessage{
				Message: v.Message,
			}
		}
		// Handle vsHostname rewrite.
		if v.Replace && v.HTTPHost {
			action.Replace = &as3ActionReplaceMap{
				Value: v.Value,
				Name:  "host",
			}
		}
		// handle uri rewrite.
		if v.Replace && v.HTTPURI {
			action.Replace = &as3ActionReplaceMap{
				Value: v.Value,
			}
		}
		p := strings.Split(v.Pool, "/")
		if v.Pool != "" {
			action.Select = &as3ActionForwardSelect{
				Pool: &as3ResourcePointer{
					Use: p[len(p)-1],
				},
			}
		}
		// WAF action
		if v.WAF {
			action.Type = "waf"
		}
		// Add policy reference
		if v.Policy != "" {
			action.Policy = &as3ResourcePointer{
				BigIP: v.Policy,
			}
		}
		if v.Enabled != nil {
			action.Enabled = v.Enabled
		}
		// Add drop action if specified
		if v.Drop {
			action.Type = "drop"
		}

		if v.PersistMethod != "" {
			switch v.PersistMethod {
			case SourceAddress:
				action.Event = "request"
				action.Type = "persist"
				action.SourceAddress = &PersistMetaData{
					Netmask: v.Netmask,
					Timeout: v.Timeout,
				}
			case DestinationAddress:
				action.Event = "request"
				action.Type = "persist"
				action.DestinationAddress = &PersistMetaData{
					Netmask: v.Netmask,
					Timeout: v.Timeout,
				}
			case CookieHash:
				action.Event = "request"
				action.Type = "persist"
				action.CookieHash = &PersistMetaData{
					Timeout: v.Timeout,
					Offset:  v.Offset,
					Length:  v.Length,
					Name:    v.Name,
				}
			case CookieInsert:
				action.Event = "request"
				action.Type = "persist"
				action.CookieInsert = &PersistMetaData{
					Name:   v.Name,
					Expiry: v.Expiry,
				}
			case CookieRewrite:
				action.Event = "request"
				action.Type = "persist"
				action.CookieRewrite = &PersistMetaData{
					Name:   v.Name,
					Expiry: v.Expiry,
				}
			case CookiePassive:
				action.Event = "request"
				action.Type = "persist"
				action.CookiePassive = &PersistMetaData{
					Name: v.Name,
				}
			case Universal:
				action.Event = "request"
				action.Type = "persist"
				action.Universal = &PersistMetaData{
					Key:     v.Key,
					Timeout: v.Timeout,
				}
			case Carp:
				action.Event = "request"
				action.Type = "persist"
				action.Carp = &PersistMetaData{
					Key:     v.Key,
					Timeout: v.Timeout,
				}
			case Hash:
				action.Event = "request"
				action.Type = "persist"
				action.Hash = &PersistMetaData{
					Key:     v.Key,
					Timeout: v.Timeout,
				}
			case Disable:
				action.Event = "request"
				action.Type = "persist"
				action.Disable = &PersistMetaData{}
			default:
				log.Warning("provide a persist method value from sourceAddress, destinationAddress, cookieInsert, cookieRewrite, cookiePassive, cookieHash, universal, hash, and carp")
			}
		}

		rulesData.Actions = append(rulesData.Actions, action)
	}
}

// Extract virtual address and port from host URL
func extractVirtualAddressAndPort(str string) (string, int) {

	destination := strings.Split(str, "/")
	// split separator is in accordance with SetVirtualAddress function - ipv4/6 format
	ipPort := strings.Split(destination[len(destination)-1], ":")
	if len(ipPort) != 2 {
		ipPort = strings.Split(destination[len(destination)-1], ".")
	}
	// verify that ip address and port exists else log error.
	if len(ipPort) == 2 {
		port, _ := strconv.Atoi(ipPort[1])
		return ipPort[0], port
	} else {
		log.Error("Invalid Virtual Server Destination IP address/Port.")
		return "", 0
	}

}

func DeepEqualJSON(decl1, decl2 as3Declaration) bool {
	if decl1 == "" && decl2 == "" {
		return true
	}
	var o1, o2 interface{}

	err := json.Unmarshal([]byte(decl1), &o1)
	if err != nil {
		return false
	}

	err = json.Unmarshal([]byte(decl2), &o2)
	if err != nil {
		return false
	}

	return reflect.DeepEqual(o1, o2)
}

func processProfilesForAS3(rsMap ResourceMap, sharedApp as3Application) {
	for _, cfg := range rsMap {
		if svc, ok := sharedApp[cfg.Virtual.Name].(*as3Service); ok {
			processTLSProfilesForAS3(&cfg.Virtual, svc, cfg.Virtual.Name)
		}
	}
}

func processTLSProfilesForAS3(virtual *Virtual, svc *as3Service, profileName string) {
	// lets discard BIGIP profile creation when there exists a custom profile.
	as3ClientSuffix := "_tls_client"
	as3ServerSuffix := "_tls_server"
	var clientProfiles []as3MultiTypeParam
	var serverProfiles []as3MultiTypeParam
	for _, profile := range virtual.Profiles {
		switch profile.Context {
		case CustomProfileClient:
			// Profile is stored in a k8s secret
			if !profile.BigIPProfile {
				// Incoming traffic (clientssl) from a web client will be handled by ServerTLS in AS3
				svc.ServerTLS = fmt.Sprintf("/%v/%v/%v%v", virtual.Partition,
					as3SharedApplication, profileName, as3ServerSuffix)

			} else {
				// Profile is a BIG-IP reference
				// Incoming traffic (clientssl) from a web client will be handled by ServerTLS in AS3
				clientProfiles = append(clientProfiles, &as3ResourcePointer{
					BigIP: fmt.Sprintf("/%v/%v", profile.Partition, profile.Name),
				})
			}
			updateVirtualToHTTPS(svc)
		case CustomProfileServer:
			// Profile is stored in a k8s secret
			if !profile.BigIPProfile {
				// Outgoing traffic (serverssl) to BackEnd Servers from BigIP will be handled by ClientTLS in AS3
				svc.ClientTLS = fmt.Sprintf("/%v/%v/%v%v", virtual.Partition,
					as3SharedApplication, profileName, as3ClientSuffix)
			} else {
				// Profile is a BIG-IP reference
				// Outgoing traffic (serverssl) to BackEnd Servers from BigIP will be handled by ClientTLS in AS3
				serverProfiles = append(serverProfiles, &as3ResourcePointer{
					BigIP: fmt.Sprintf("/%v/%v", profile.Partition, profile.Name),
				})
			}
			updateVirtualToHTTPS(svc)
		}
	}
	if len(clientProfiles) > 0 {
		svc.ServerTLS = clientProfiles
	}
	if len(serverProfiles) > 0 {
		svc.ClientTLS = serverProfiles
	}
}

func processCustomProfilesForAS3(rsMap ResourceMap, sharedApp as3Application, as3Version float64) {
	caBundleName := "serverssl_ca_bundle"
	var tlsClient *as3TLSClient
	svcNameMap := make(map[string]struct{})
	// TLS Certificates are available in CustomProfiles
	for _, rsCfg := range rsMap {
		// Sort customProfiles so that they are processed in orderly manner
		keys := getSortedCustomProfileKeys(rsCfg.customProfiles)

		for _, key := range keys {
			prof := rsCfg.customProfiles[key]
			// Create TLSServer and Certificate for each profile
			svcName := key.ResourceName
			if svcName == "" {
				continue
			}
			if ok := createUpdateTLSServer(prof, svcName, sharedApp); ok {
				// Create Certificate only if the corresponding TLSServer is created
				createCertificateDecl(prof, sharedApp)
				svcNameMap[svcName] = struct{}{}
			} else {
				createUpdateCABundle(prof, caBundleName, sharedApp)
				tlsClient = createTLSClient(prof, svcName, caBundleName, sharedApp)

				skey := SecretKey{
					Name: prof.Name + "-ca",
				}
				if _, ok := rsCfg.customProfiles[skey]; ok && tlsClient != nil {
					// If a profile exist in customProfiles with key as created above
					// then it indicates that secure-serverssl needs to be added
					tlsClient.ValidateCertificate = true
				}
			}
		}
	}
	// if AS3 version on bigIP is lower than 3.44 then don't enable sniDefault, as it's only supported from AS3 v3.44 onwards
	if as3Version < 3.44 {
		return
	}
	for svcName, _ := range svcNameMap {
		if _, ok := sharedApp[svcName].(*as3Service); ok {
			tlsServerName := fmt.Sprintf("%s_tls_server", svcName)
			tlsServer, ok := sharedApp[tlsServerName].(*as3TLSServer)
			if !ok {
				continue
			}
			if len(tlsServer.Certificates) > 1 {
				tlsServer.Certificates[0].SNIDefault = true
			}
		}
	}
}

// createUpdateTLSServer creates a new TLSServer instance or updates if one exists already
func createUpdateTLSServer(prof CustomProfile, svcName string, sharedApp as3Application) bool {
	if len(prof.Certificates) > 0 {
		if sharedApp[svcName] == nil {
			return false
		}
		svc := sharedApp[svcName].(*as3Service)
		tlsServerName := fmt.Sprintf("%s_tls_server", svcName)
		tlsServer, ok := sharedApp[tlsServerName].(*as3TLSServer)
		if !ok {
			tlsServer = &as3TLSServer{
				Class:        "TLS_Server",
				Certificates: []as3TLSServerCertificates{},
			}
			if prof.TLS1_0Enabled != nil {
				tlsServer.TLS1_0Enabled = prof.TLS1_0Enabled
			}
			if prof.TLS1_1Enabled != nil {
				tlsServer.TLS1_1Enabled = prof.TLS1_1Enabled
			}
			if prof.TLS1_2Enabled != nil {
				tlsServer.TLS1_2Enabled = prof.TLS1_2Enabled
			}
			if prof.CipherGroup != "" {
				tlsServer.CipherGroup = &as3ResourcePointer{BigIP: prof.CipherGroup}
				tlsServer.TLS1_3Enabled = true
			} else {
				tlsServer.Ciphers = prof.Ciphers
			}
			if prof.RenegotiationEnabled != nil {
				tlsServer.RenegotiationEnabled = prof.RenegotiationEnabled
			}
			sharedApp[tlsServerName] = tlsServer
			svc.ServerTLS = tlsServerName
			updateVirtualToHTTPS(svc)
		}
		for index, certificate := range prof.Certificates {
			certName := fmt.Sprintf("%s_%d", prof.Name, index)
			// A TLSServer profile needs to carry both Certificate and Key
			if len(certificate.Cert) > 0 && len(certificate.Key) > 0 {
				tlsServer.Certificates = append(
					tlsServer.Certificates,
					as3TLSServerCertificates{
						Certificate: certName,
					},
				)
			} else {
				return false
			}
		}
		return true
	}
	return false
}

func createCertificateDecl(prof CustomProfile, sharedApp as3Application) {
	for index, certificate := range prof.Certificates {
		if len(certificate.Cert) > 0 && len(certificate.Key) > 0 {
			cert := &as3Certificate{
				Class:       "Certificate",
				Certificate: certificate.Cert,
				PrivateKey:  certificate.Key,
				ChainCA:     prof.CAFile,
			}
			sharedApp[fmt.Sprintf("%s_%d", prof.Name, index)] = cert
		}
	}
}

func createUpdateCABundle(prof CustomProfile, caBundleName string, sharedApp as3Application) {
	for _, cert := range prof.Certificates {
		// For TLSClient only Cert (DestinationCACertificate) is given and key is empty string
		if len(cert.Cert) > 0 && len(cert.Key) == 0 {
			caBundle, ok := sharedApp[caBundleName].(*as3CABundle)

			if !ok {
				caBundle = &as3CABundle{
					Class:  "CA_Bundle",
					Bundle: "",
				}
				sharedApp[caBundleName] = caBundle
			}
			caBundle.Bundle += "\n" + cert.Cert
		}
	}
}

func createTLSClient(
	prof CustomProfile,
	svcName, caBundleName string,
	sharedApp as3Application,
) *as3TLSClient {

	// For TLSClient only Cert (DestinationCACertificate) is given and key is empty string
	for _, certificate := range prof.Certificates {
		if certificate.Key != "" {
			return nil
		}
	}
	if _, ok := sharedApp[svcName]; len(prof.Certificates) > 0 && ok {
		svc := sharedApp[svcName].(*as3Service)
		tlsClientName := fmt.Sprintf("%s_tls_client", svcName)

		tlsClient := &as3TLSClient{
			Class: "TLS_Client",
			TrustCA: &as3ResourcePointer{
				Use: caBundleName,
			},
		}
		if prof.TLS1_0Enabled != nil {
			tlsClient.TLS1_0Enabled = prof.TLS1_0Enabled
		}
		if prof.TLS1_1Enabled != nil {
			tlsClient.TLS1_1Enabled = prof.TLS1_1Enabled
		}
		if prof.TLS1_2Enabled != nil {
			tlsClient.TLS1_2Enabled = prof.TLS1_2Enabled
		}
		if prof.CipherGroup != "" {
			tlsClient.CipherGroup = &as3ResourcePointer{BigIP: prof.CipherGroup}
			tlsClient.TLS1_3Enabled = true
		} else {
			tlsClient.Ciphers = prof.Ciphers
		}
		if prof.RenegotiationEnabled != nil {
			tlsClient.RenegotiationEnabled = prof.RenegotiationEnabled
		}
		sharedApp[tlsClientName] = tlsClient
		svc.ClientTLS = tlsClientName
		updateVirtualToHTTPS(svc)

		return tlsClient
	}
	return nil
}

// Create health monitor declaration
func createMonitorDecl(cfg *ResourceConfig, sharedApp as3Application) {

	for _, v := range cfg.Monitors {
		monitor := &as3Monitor{}
		monitor.Class = "Monitor"
		monitor.Interval = v.Interval
		monitor.MonitorType = v.Type
		monitor.Timeout = v.Timeout
		val := 0
		monitor.TargetPort = v.TargetPort
		targetAddressStr := ""
		monitor.TargetAddress = &targetAddressStr
		monitor.TimeUnitilUp = v.TimeUntilUp
		//Monitor type
		switch v.Type {
		case "http":
			adaptiveFalse := false
			monitor.Adaptive = &adaptiveFalse
			monitor.Dscp = &val
			monitor.Receive = "none"
			if v.Recv != "" {
				monitor.Receive = v.Recv
			}
			monitor.Send = v.Send
		case "https":
			//Todo: For https monitor type
			adaptiveFalse := false
			monitor.Adaptive = &adaptiveFalse
			if v.Recv != "" {
				monitor.Receive = v.Recv
			}
			monitor.Send = v.Send
			monitor.TimeUnitilUp = v.TimeUntilUp
			if v.SSLProfile != "" {
				monitor.ClientTLS = &as3ResourcePointer{BigIP: fmt.Sprintf("%v", v.SSLProfile)}
			}
		case "tcp", "udp":
			adaptiveFalse := false
			monitor.Adaptive = &adaptiveFalse
			monitor.Receive = v.Recv
			monitor.Send = v.Send
		}
		sharedApp[v.Name] = monitor
	}

}

// Create AS3 transport Service for CRD
func createTransportServiceDecl(cfg *ResourceConfig, sharedApp as3Application, tenant string) {
	svc := &as3Service{}
	if cfg.Virtual.Mode == "standard" {
		if cfg.Virtual.IpProtocol == "udp" {
			svc.Class = "Service_UDP"
		} else if cfg.Virtual.IpProtocol == "sctp" {
			svc.Class = "Service_SCTP"
		} else {
			svc.Class = "Service_TCP"
			//set ftp profile for only TCP
			if cfg.Virtual.FTPProfile != "" {
				svc.ProfileFTP = &as3ResourcePointer{
					BigIP: cfg.Virtual.FTPProfile,
				}
			}
		}
	} else if cfg.Virtual.Mode == "performance" {
		svc.Class = "Service_L4"
		if cfg.Virtual.IpProtocol == "udp" {
			svc.Layer4 = "udp"
		} else if cfg.Virtual.IpProtocol == "sctp" {
			svc.Layer4 = "sctp"
		} else {
			svc.Layer4 = "tcp"
		}
	}

	svc.ProfileL4 = "basic"
	if len(cfg.Virtual.ProfileL4) > 0 {
		svc.ProfileL4 = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileL4,
		}
	}

	svc.addPersistenceMethod(cfg.Virtual.PersistenceProfile)

	if len(cfg.Virtual.ProfileDOS) > 0 {
		svc.ProfileDOS = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileDOS,
		}
	}

	if len(cfg.Virtual.ProfileBotDefense) > 0 {
		svc.ProfileBotDefense = &as3ResourcePointer{
			BigIP: cfg.Virtual.ProfileBotDefense,
		}
	}

	if len(cfg.Virtual.TCP.Client) > 0 || len(cfg.Virtual.TCP.Server) > 0 {
		if cfg.Virtual.TCP.Client == "" {
			log.Errorf("[AS3] resetting ProfileTCP as client profile doesnt co-exist with TCP Server Profile, Please include client TCP Profile ")
		}
		if cfg.Virtual.TCP.Server == "" {
			svc.ProfileTCP = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
			}
		}
		if cfg.Virtual.TCP.Client != "" && cfg.Virtual.TCP.Server != "" {
			svc.ProfileTCP = as3ProfileTCP{
				Ingress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Client),
				},
				Egress: &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", cfg.Virtual.TCP.Server),
				},
			}
		}
	}

	// Attaching Profiles from Policy CRD
	for _, profile := range cfg.Virtual.Profiles {
		_, name := getPartitionAndName(profile.Name)
		switch profile.Context {
		case "udp":
			if !profile.BigIPProfile {
				svc.ProfileUDP = name
			} else {
				svc.ProfileUDP = &as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", profile.Name),
				}
			}
		}
	}

	if cfg.Virtual.TranslateServerAddress == true {
		svc.TranslateServerAddress = cfg.Virtual.TranslateServerAddress
	}
	if cfg.Virtual.TranslateServerPort == true {
		svc.TranslateServerPort = cfg.Virtual.TranslateServerPort
	}
	if cfg.Virtual.Source != "" {
		svc.Source = cfg.Virtual.Source
	}
	virtualAddress, port := extractVirtualAddressAndPort(cfg.Virtual.Destination)
	// verify that ip address and port exists.
	if virtualAddress != "" && port != 0 {
		if len(cfg.ServiceAddress) == 0 {
			va := append(svc.VirtualAddresses, virtualAddress)
			svc.VirtualAddresses = va
			svc.VirtualPort = port
		} else {
			//Attach Service Address
			serviceAddressName := createServiceAddressDecl(cfg, virtualAddress, sharedApp)
			sa := &as3ResourcePointer{
				Use: serviceAddressName,
			}
			svc.VirtualAddresses = append(svc.VirtualAddresses, sa)
			svc.VirtualPort = port
		}
	}
	if cfg.Virtual.PoolName != "" {
		var poolPointer as3ResourcePointer
		ps := strings.Split(cfg.Virtual.PoolName, "/")
		poolPointer.Use = fmt.Sprintf("/%s/%s/%s",
			tenant,
			as3SharedApplication,
			ps[len(ps)-1],
		)
		svc.Pool = &poolPointer
	}
	processCommonDecl(cfg, svc)
	sharedApp[cfg.Virtual.Name] = svc
}

// Process common declaration for VS and TS
func processCommonDecl(cfg *ResourceConfig, svc *as3Service) {

	if cfg.Virtual.SNAT == "auto" || cfg.Virtual.SNAT == "none" || cfg.Virtual.SNAT == "self" {
		svc.SNAT = cfg.Virtual.SNAT
	} else {
		svc.SNAT = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.SNAT),
		}
	}
	// Enable connection mirroring
	if cfg.Virtual.ConnectionMirroring != "" {
		svc.Mirroring = cfg.Virtual.ConnectionMirroring
	}
	//Attach AllowVLANs
	if cfg.Virtual.AllowVLANs != nil {
		for _, vlan := range cfg.Virtual.AllowVLANs {
			vlans := as3ResourcePointer{BigIP: vlan}
			svc.AllowVLANs = append(svc.AllowVLANs, vlans)
		}
	}

	//Attach Firewall policy
	if cfg.Virtual.Firewall != "" {
		svc.Firewall = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.Firewall),
		}
	}

	//Attach ipIntelligence policy
	if cfg.Virtual.IpIntelligencePolicy != "" {
		svc.IpIntelligencePolicy = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.IpIntelligencePolicy),
		}
	}

	//Attach profile access policy
	// if perRequest policy is enabled, profile access policy should also be configured
	if cfg.Virtual.ProfileAccess != "" {
		svc.ProfileAccess = &as3ResourcePointer{
			BigIP: fmt.Sprintf("%v", cfg.Virtual.ProfileAccess),
		}

		//Attach per request policy
		if cfg.Virtual.PolicyPerRequestAccess != "" {
			svc.PolicyPerRequestAccess = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.PolicyPerRequestAccess),
			}
		}
	}

	//Attach logging profile
	if cfg.Virtual.LogProfiles != nil {
		for _, lp := range cfg.Virtual.LogProfiles {
			logProfile := as3ResourcePointer{BigIP: lp}
			svc.LogProfiles = append(svc.LogProfiles, logProfile)
		}
	}

	//Attach adapt profile
	if (cfg.Virtual.ProfileAdapt != ProfileAdapt{}) {
		if cfg.Virtual.ProfileAdapt.Request != "" {
			svc.ProfileRequestAdapt = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.ProfileAdapt.Request),
			}
		}
		if cfg.Virtual.ProfileAdapt.Response != "" {
			svc.ProfileResponseAdapt = &as3ResourcePointer{
				BigIP: fmt.Sprintf("%v", cfg.Virtual.ProfileAdapt.Response),
			}
		}
	}

	//Process iRules for crd
	processIrulesForCRD(cfg, svc)
}

// getSortedCustomProfileKeys sorts customProfiles by names and returns secretKeys in that order
func getSortedCustomProfileKeys(customProfiles map[SecretKey]CustomProfile) []SecretKey {
	keys := make([]SecretKey, len(customProfiles))
	i := 0
	for key := range customProfiles {
		keys[i] = key
		i++
	}
	sort.Slice(keys, func(i, j int) bool {
		return customProfiles[keys[i]].Name < customProfiles[keys[j]].Name
	})
	return keys
}

// addPersistenceMethod adds persistence methods in the service declaration
func (svc *as3Service) addPersistenceMethod(persistenceProfile string) {
	if len(persistenceProfile) == 0 {
		return
	}
	switch persistenceProfile {
	case "none":
		svc.PersistenceMethods = &[]as3MultiTypeParam{}
	case "cookie", "destination-address", "hash", "msrdp", "sip-info", "source-address", "tls-session-id", "universal":
		svc.PersistenceMethods = &[]as3MultiTypeParam{as3MultiTypeParam(persistenceProfile)}
	default:
		svc.PersistenceMethods = &[]as3MultiTypeParam{
			as3MultiTypeParam(
				as3ResourcePointer{
					BigIP: fmt.Sprintf("%v", persistenceProfile),
				},
			),
		}
	}
}

func (agent *Agent) isGTMTenant(partition string) bool {
	return partition == DEFAULT_GTM_PARTITION
}
